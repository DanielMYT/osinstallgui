#!/usr/bin/env bash

# osinstallgui version @@VERSION@@ - Copyright (C) 2025 Daniel Massey.
# Rewrite of installation program originally from MassOS, now with GTK3 GUI.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# The configuration file is set correctly after running 'make'.
# shellcheck disable=SC1091

# Word splitting is often done intentionally, and/or the command handles it.
# shellcheck disable=SC2086

# We manually check configuration values and set them (or die) if unset.
# shellcheck disable=SC2153

# We intentionally ignore return values from declarations in most cases.
# shellcheck disable=SC2155

# What is our name, what is our version?
export inv="$(basename "$0")"
export ver="@@VERSION@@"

# Function to write a message to the log file.
write_log() {
  echo "=== $* ===" >>"$log"
}

# Function to display an error message and exit with error.
die() {
  echo "ERROR: $*" >&2
  write_log "ERROR: $*"
  exit 1
}

# Function to display warning message.
warn() {
  echo "WARNING: $*" >&2
  write_log "WARNING: $*"
}

# Check dependency - exit if they are not found.
check_dep() {
  # $1 is the program, $2 is the package it comes from (if different).
  if ! which "$1" &>/dev/null; then
    if test ! -z "$2"; then
      die "$inv requires $1 ($2) in order to run, but it was not found."
    else
      die "$inv requires $1 in order to run, but it was not found."
    fi
  fi
}

# Functions for displaying each screen type using yad.
yad_menu() {
  local title="$1 ⎯ $inv"
  local menu="$2"
  shift 2
  local response="$(yad --list --title="$title" --text="$menu" --column="Option" --column="Description" "$@" --width=600 --height=300)"
  echo "$response"
}
yad_message() {
  yad --title="$1 ⎯ $inv" --text="$2" --width=600 --height=200 --button="OK":0
}
yad_prompt() {
  yad --title="$1 ⎯ $inv" --text="$2" --width=600 --height=200 --button="Yes":0 --button="No":1
  return $?
}
yad_input() {
  local title="$1 ⎯ $inv"
  local text="$2"
  local placeholder="$3"
  # This is the only exception to disabling SC2155, but we deal with it.
  local response
  response="$(yad --entry --title="$title" --text="$text" --entry-text="$placeholder" --width=600 --height=100 --button="OK":0)"
  local status=$?
  echo "$response"
  return $status
}
yad_password() {
  local title="$1 ⎯ $inv"
  local text="$2"
  # This is the only exception to disabling SC2155, but we deal with it.
  local response
  response="$(yad --entry --title="$title" --text="$text" --hide-text --width=600 --height=100 --button="OK":0)"
  local status=$?
  echo "$response"
  return $status
}

# Helper functions.
helper_sortentries() {
  # This function will sort an array of yad menu entries by description.
  # Do nothing if no argument was passed.
  test ! -z "$1" || return
  # Get the array.
  local itemsunsorted=()
  for item in "$@"; do
    itemsunsorted+=("$item")
  done
  # Set up the files for writing and reading back.
  # TODO: See if this whole process could be done without using files on disk.
  local sortfilepre1="$(mktemp "$workdir"/.sortpre1XXXXXX)"
  local sortfilepre2="$(mktemp "$workdir"/.sortpre2XXXXXX)"
  local sortfilepost1="$(mktemp "$workdir"/.sortpost1XXXXXX)"
  local sortfilepost2="$(mktemp "$workdir"/.sortpost2XXXXXX)"
  # Write every 1st entry to a file, and every 2nd entry to a file.
  # Do this by iterating through using the array index, not the item itself.
  for item in "${!itemsunsorted[@]}"; do
    if test $((item % 2)) -eq 0; then
      # 1st entry.
      echo "${itemsunsorted[item]}" >>"$sortfilepre1"
    else
      # 2nd entry.
      echo "${itemsunsorted[item]}" >>"$sortfilepre2"
    fi
  done
  # Sort timezones, if needed. Otherwise, sort normally by alphabetical order.
  if test "$SORTTZ" = "1"; then
    # We want to sort by UTC offset.
    # Where -12 is the first, and +12 is the last.
    # To do this, get the negative values and sort in reverse.
    # Then get the positive values and sort normally.
    paste "$sortfilepre1" "$sortfilepre2" | grep -- - | sort -rk2 | cut -f1 >"$sortfilepost1"
    paste "$sortfilepre1" "$sortfilepre2" | grep -- - | sort -rk2 | cut -f2 >"$sortfilepost2"
    paste "$sortfilepre1" "$sortfilepre2" | grep -- + | sort -k2 | cut -f1 >>"$sortfilepost1"
    paste "$sortfilepre1" "$sortfilepre2" | grep -- + | sort -k2 | cut -f2 >>"$sortfilepost2"
  else
    paste "$sortfilepre1" "$sortfilepre2" | sort -k2 | cut -f1 >"$sortfilepost1"
    paste "$sortfilepre1" "$sortfilepre2" | sort -k2 | cut -f2 >"$sortfilepost2"
  fi
  # Sort by the 2nd column (description), but keep consistent for 1st too.
  # Open file descriptors for both files, so we can access them while looping.
  # Use high numbers, in case lower ones are already in use for some reason.
  exec 99<"$sortfilepost1"
  exec 100<"$sortfilepost2"
  # Loop through and print each alternating line to stdout.
  while true; do
    # Break out of the loop when either read no longer succeeds (end of file).
    if read -r line1 <&99; then
      echo "$line1"
    else
      break
    fi
    if read -r line2 <&100; then
      echo "$line2"
    else
      break
    fi
  done
  # Close the file descriptors.
  exec 99<&-
  exec 100<&-
  # Now we are done, remove the temporary files.
  rm -f "$sortfilepre1" "$sortfilepre2" "$sortfilepost1" "$sortfilepost2"
}
helper_format() {
  write_log "Trying to format $1 as $2."
  case "$2" in
    ext4) mkfs.ext4 -vFL "$3" "$1" &>>"$log" ;;
    btrfs) mkfs.btrfs -vfL "$3" "$1"&>>"$log" ;;
    swap) mkswap "$1" &>>"$log" ;;
    vfat) mkfs.fat -F32 -vn "$3" "$1" &>>"$log" ;;
  esac
  local status=$?
  if test $status -eq 0; then
    write_log "Format of $1 as $2 was successful."
  else
    write_log "Format of $1 as $2 was unsuccessful."
  fi
  return $status
}
helper_mount() {
  write_log "Trying to mount $1 at $2."
  mkdir -pv "$2" &>>"$log"
  mount -v "$1" "$2" &>>"$log"
  local status=$?
  if test $status -eq 0; then
    write_log "$1 was successfully mounted at $2."
  else
    write_log "$1 was unable to be mounted at $2."
  fi
  return $status
}
helper_umount() {
  write_log "Trying to unmount $1."
  umount -Rv "$1" &>>"$log"
  local status=$?
  if test $status -eq 0; then
    write_log "$1 was successfully unmounted."
  else
    write_log "$1 was unable to be unmounted."
  fi
  return $status
}
helper_chroot_advanced() {
  # Chroot with aspirations - setting up virtual filesystems too.
  # Partially adapted from the 'mass-chroot' utility from MassOS.
  test ! -z "$1" || return
  local chrootdir="$1"
  shift
  write_log "Trying to enter an advanced chroot in $chrootdir."
  # Mount virtual filesystems.
  sync
  mount -v --bind /dev "$chrootdir"/dev &>>"$log" || return
  mount -v --bind /dev/pts "$chrootdir"/dev/pts &>>"$log" || return
  mount -vt tmpfs devshm "$chrootdir"/dev/shm &>>"$log" || return
  mount -vt proc proc "$chrootdir"/proc &>>"$log" || return
  mount -vt sysfs sysfs "$chrootdir"/sys &>>"$log" || return
  mount -vt tmpfs tmpfs "$chrootdir"/run &>>"$log" || return
  mkdir -vp "$chrootdir"/run/lock &>>"$log"
  if test $efimode -eq 1; then
    # Need to also mount efivarfs filesystem for UEFI boot mode.
    mount -vt efivarfs efivarfs "$chrootdir"/sys/firmware/efi/efivars &>>"$log" || return
  fi
  sync
  # Enter the chroot.
  chroot "$chrootdir" "$@" &>>"$log"
  local chrootstatus=$?
  # Unmount virtual filesystems.
  sync
  if test $efimode -eq 1; then
    umount -Rv "$chrootdir"/sys/firmware/efi/efivars &>>"$log" || return
  fi
  umount -Rv "$chrootdir"/dev/pts &>>"$log" || return
  umount -Rv "$chrootdir"/dev/shm &>>"$log" || return
  umount -Rv "$chrootdir"/dev &>>"$log" || return
  umount -Rv "$chrootdir"/proc &>>"$log" || return
  umount -Rv "$chrootdir"/sys &>>"$log" || return
  umount -Rv "$chrootdir"/run &>>"$log" || return
  sync
  # Report the result and return.
  if test $chrootstatus -eq 0; then
    write_log "Advanced chroot exited after successful exit code."
  else
    write_log "Advanced chroot exited after unsuccessful exit code $chrootstatus."
  fi
  return $chrootstatus
}

# Preloader function - finds locales/keymaps now to prevent slowdown later.
preloader() {
  # A progress bar is needed here, since preloading can take around 15 seconds.
  # Unfortunately, the previous pipe method would cause variables to be lost.
  # This new method involves using coproc, to avoid any piping or subshells.
  # TODO: Make this the default elsewhere too.
  coproc preloaderprogress { yad --progress --title="Loading... ⎯ $inv" --text="The installer is loading, please be patient." --percentage=0 --auto-close --auto-kill --no-buttons --no-escape --width=600 --height=100; }
  # Set up the list of locales, as well as the list of the most common ones.
  write_log "Preloading locales."
  # Arrays to store the stuff into (u is for unsorted, will be sorted later).
  local ulocales=() ulocalescore=()
  # Acceptable core locales - searched locales will be matched against this.
  local localescorelist="de_DE.UTF-8 el_GR.UTF-8 en_GB.UTF-8 en_US.UTF-8 es_ES.UTF-8 es_MX.UTF-8 fr_FR.UTF-8 it_IT.UTF-8 pl_PL.UTF-8 pt_BR.UTF-8 pt_PT.UTF-8 ro_RO.UTF-8 ru_RU.UTF-8 sv_SE.UTF-8"
  # Get a list of locales from the locales file.
  while IFS= read -r line; do
    # Filter the line and then uncomment it.
    # We are filtering for UTF-8 and no comments with space between # and text.
    # We also filter out C.UTF-8, as it's in the locales file as of Glibc 2.41.
    local linefiltered="$(echo "$line" | grep UTF-8 | cut -d' ' -f1 | sed -e '/^#\s.*$/d' -e 's/#//' | sed '/^C.UTF-8/d')"
    # Only append to the list of locales if this line exists.
    if test ! -z "$linefiltered"; then
      # Cross-reference the locale descriptions data file.
      local localedesc="$(grep -sm1 "^$linefiltered:" "@@CONFPATH@@"/data/locales.desc | cut -d' ' -f2-)"
      if test -z "$localedesc"; then
        # Either locales.desc file was missing or no match was found.
        localedesc="UNKNOWN"
      fi
      # Add both the filtered locale name and its description to the list.
      ulocales+=("$linefiltered" "$localedesc")
      # If it should be in the core list, add it to that.
      for corelocale in $localescorelist; do
        if test "$corelocale" = "$linefiltered"; then
          ulocalescore+=("$linefiltered" "$localedesc")
        fi
      done
    fi
  done < "$OSINSTALLGUI_LOCALES_FILE"
  write_log "Successfully preloaded locales."
  echo "20" >&"${preloaderprogress[1]}"
  # Get a list of all supported keymaps.
  write_log "Preloading console keymaps."
  local keymapsavailable=()
  # Use the systemd localectl method if possible, otherwise search manually.
  if test "$OSINSTALLGUI_KEYMAPS_SYSTEMD" = "1" && which localectl &>/dev/null; then
    readarray -t keymapsavailable < <(localectl list-keymaps | sort -u)
  else
    readarray -t keymapsavailable < <(find "$OSINSTALLGUI_KEYMAPS_LOCATION" -type f -name \*.map.gz -exec basename {} \; | sort -u | sed 's/.map.gz//')
  fi
  # Arrays to store the stuff into (u is for unsorted, will be sorted later).
  local ukeymaps=() ukeymapscore=()
  # Define the core keymaps - the most common ones, similar to as above.
  local keymapscommon="de el es fr it pl pt ro ru sv uk us"
  # Get descriptions for each keymap.
  for keymap in "${keymapsavailable[@]}"; do
    # Cross-reference the keymap descriptions data file.
    local keymapdesc="$(grep -sm1 "^$keymap:" "@@CONFPATH@@"/data/keymaps.desc | cut -d' ' -f2-)"
    if test -z "$keymapdesc"; then
      # Either the keymaps.desc file was missing or no match was found.
      keymapdesc="UNKNOWN"
    fi
    # Add both the keymap name and its description to the list.
    ukeymaps+=("$keymap" "$keymapdesc")
    # If it should be in the core list, add it to that.
    for corekeymap in $keymapscommon; do
      if test "$corekeymap" = "$keymap"; then
        ukeymapscore+=("$keymap" "$keymapdesc")
      fi
    done
  done
  write_log "Successfully preloaded console keymaps."
  echo "40" >&"${preloaderprogress[1]}"
  # Get a list of all supported X11 keymaps (layouts, variants, descriptions).
  write_log "Preloading X11 keymaps."
  local x11layouts=() x11variants=() x11descriptions=()
  # Arrays to store the stuff into (u is for unsorted, will be sorted later).
  local ux11keys=() ux11keyscore=()
  # Set up the core values.
  local x11keyscorelist="de es fr gb gr it pl pt ro ru se us"
  # Need to write to temporary files because reading from pipe fails.
  xkbcli list | yq -o shell '.layouts[]' | grep '^layout=' | sed 's/^layout=//' > "$workdir"/.x11l
  xkbcli list | yq -o shell '.layouts[]' | grep '^variant=' | sed 's/^variant=//' | sed "s/'//g" > "$workdir"/.x11v
  xkbcli list | yq -o shell '.layouts[]' | grep '^description=' | sed 's/^description=//' | sed "s/'//g" > "$workdir"/.x11d
  # Read back the temporary files into the arrays.
  while IFS= read -r line; do
    x11layouts+=("$line")
  done < "$workdir"/.x11l
  while IFS= read -r line; do
    x11variants+=("$line")
  done < "$workdir"/.x11v
  while IFS= read -r line; do
    x11descriptions+=("$line")
  done < "$workdir"/.x11d
  # Remove temporary files now they are no longer needed.
  rm -f "$workdir"/.x11{l,v,d}
  # Remove last value from each array due to it being the 'custom' entry.
  unset "x11layouts[-1]" "x11variants[-1]" "x11descriptions[-1]"
  # Now prepare in a yad-friendly format ("layout_variant" "description").
  # Underscore is useful for displaying to user, and we can manually handle it.
  # Loop through in index mode because we also need to access other arrays.
  for x11index in "${!x11layouts[@]}"; do
    # If variant is empty, only add the layout. Otherwise add both.
    if test -z "${x11variants[x11index]}"; then
      ux11keys+=("${x11layouts[x11index]}" "${x11descriptions[x11index]}")
      # If it should be in the core list, also add it to that.
      # Note that only non-variant ones are in the core list.
      for corex11map in $x11keyscorelist; do
        if test "$corex11map" = "${x11layouts[x11index]}"; then
          ux11keyscore+=("${x11layouts[x11index]}" "${x11descriptions[x11index]}")
        fi
      done
    else
      ux11keys+=("${x11layouts[x11index]}_${x11variants[x11index]}" "${x11descriptions[x11index]}")
    fi
  done
  write_log "Successfully preloaded X11 keymaps."
  echo "60" >&"${preloaderprogress[1]}"
  # Get a list of timezones, based on each major region.
  write_log "Preloading timezones."
  local utimezones=()
  for region in $(find /usr/share/zoneinfo -mindepth 1 -maxdepth 1 -type d ! -name right ! -name posix ! -name Etc ! -name Brazil ! -name Canada ! -name Chile ! -name Mexico ! -name US -exec basename {} \; | sort -u); do
    # Find each city within this region.
    for timezone in $(find /usr/share/zoneinfo/"$region" -mindepth 1 -maxdepth 1 -type f | sed 's|^/usr/share/zoneinfo/||'); do
      # Add it to the list of timezones, getting the UTC offset.
      # Use a sed to ensure "UTC" is prepended to every entry.
      utimezones+=("$timezone" "$(TZ="$timezone" date +%z | sed -e 's/-/UTC-/' -e 's/+/UTC+/')")
    done
  done
  write_log "Succesfully preloaded timezones."
  echo "80" >&"${preloaderprogress[1]}"
  # Sort each set of entries by description.
  # Store them into the normal/global (non-u) variable names.
  write_log "Sorting all sets of entries by their descriptions."
  readarray -t locales < <(helper_sortentries "${ulocales[@]}")
  readarray -t localescore < <(helper_sortentries "${ulocalescore[@]}")
  readarray -t keymaps < <(helper_sortentries "${ukeymaps[@]}")
  readarray -t keymapscore < <(helper_sortentries "${ukeymapscore[@]}")
  readarray -t x11keys < <(helper_sortentries "${ux11keys[@]}")
  readarray -t x11keyscore < <(helper_sortentries "${ux11keyscore[@]}")
  readarray -t timezones < <(SORTTZ=1 helper_sortentries "${utimezones[@]}")
  write_log "Successfully sorted all sets of entries by their descriptions."
  echo "100" >&"${preloaderprogress[1]}"
  # Export needed global variables from this preloader function.
  export locales localescore keymaps keymapscore x11keys x11keyscore timezones
}

# Stage functions.
stage_mainmenu() {
  # Let the user choose what they want to do on the main menu.
  local choice="$(yad_menu "Main Menu" "Welcome to $osname! What would you like to do?" \
  "Install" "Begin the installation of $osname onto your system." \
  "About" "See information about this installation program." \
  "Restart" "Restart the system." \
  "Shutdown" "Shut down the system." \
  "Exit" "Exit this installation program.")"
  case "${choice%%|*}" in
    "Install") stage_inc ;;
    "About") yad_message "About" "This is osinstallgui version $ver, running on $osname, accessing data from @@CONFPATH@@, and working out of the directory $workdir.\n\nosinstallgui is a full rewrite of the installation program originally from MassOS, now yad-based (GTK3 GUI) as opposed to dialog-based (Ncurses TUI). It has also been redesigned from the ground-up to be more distribution-independent, and now uses much more robust state-machine-based logic under the hood.\n\nosinstallgui was created by Daniel Massey, and is licensed under the GNU General Public License version 3 or later. More information about the project, along with its source code, can be found at <a href='https://github.com/DanielMYT/osinstallgui'>https://github.com/DanielMYT/osinstallgui</a>." ;;
    "Restart") shutdown -r now ;;
    "Shutdown") shutdown -h now ;;
    "Exit"|"") exit 0 ;;
  esac
}
stage_locale() {
  # Ask the user to select a core locale, or "Other" for all locales.
  local choice="$(yad_menu "Language Setup" "Please select the locale which corresponds to your preferred language. Choose 'Other' to see all locales." "${localescore[@]}" "Other" "Show all available locales")"
  choice="${choice%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice"; then
    stage_dec
    return
  fi
  # If the user selected "Other", then go to the submenu.
  if test "$choice" = "Other"; then
    # Ask the user to select from all possible locales.
    choice="$(yad_menu "Language Setup" "Please select the locale which corresponds to your preferred language. This is the list of all available locales." "${locales[@]}")"
    choice="${choice%%|*}"
    # Start locale setup again if the user backed out of this submenu.
    test ! -z "$choice" || return
  fi
  # Save the choice to the global configuration and move to the next stage.
  export tgtlocale="$choice"
  stage_inc
}
stage_keymap() {
  # Ask the user to select a core keymap, or "Other" for all keymaps.
  local choice="$(yad_menu "Keyboard Setup" "Please select the console keymap which corresponds to your preferred keyboard layout. Choose 'Other' to see all keymaps." "${keymapscore[@]}" "Other" "Show all available keymaps and variants")"
  choice="${choice%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice"; then
    stage_dec
    return
  fi
  # If the user selected "Other", then go to the submenu.
  if test "$choice" = "Other"; then
    # Ask the user to select from all possible keymaps.
    choice="$(yad_menu "Keyboard Setup" "Please select the console keymap which corresponds to your preferred keyboard layout. This is the list of all available keymaps and variants." "${keymaps[@]}")"
    choice="${choice%%|*}"
    # Start keymap setup again if the user backed out of this submenu.
    test ! -z "$choice" || return
  fi
  # Save the choice to the global configuration and move to the next stage.
  export tgtkeymap="$choice"
  stage_inc
}
stage_x11key() {
  # Ask the user to select an X11 keymap.
  local choice="$(yad_menu "Keyboard Setup" "Please select the X11 keymap which best corresponds to your preferred layout. Choose 'Other' to see all keymaps." "${x11keyscore[@]}" "Other" "Show all available keymaps and variants")"
  choice="${choice%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice"; then
    stage_dec
    return
  fi
  # If the user selected "Other", then go to the submenu.
  if test "$choice" = "Other"; then
    # Ask the user to select from all possible keymaps.
    choice="$(yad_menu "Keyboard Setup" "Please select the X11 keymap which corresponds to your preferred keyboard layout. This is the list of all available keymaps and variants." "${x11keys[@]}")"
    choice="${choice%%|*}"
    # Start keymap setup again if the user backed out of this submenu.
    test ! -z "$choice" || return
  fi
  # Save the choice to the global configuration and move to the next stage.
  export tgtx11key="$choice"
  stage_inc
}
stage_timezone() {
  # Let the user decide which region are in, before finding the cities.
  local choice_tz="$(yad_menu "Timezone Setup" "Please select the timezone which best corresponds to your geographical location. Note that these are sorted by their offsets from UTC (Universal Coordinated Time), with daylight saving time accounted for (if applicable)." "${timezones[@]}")"
  choice_tz="${choice_tz%%|*}"
  # Go back to the previous stage if the user backs out.
  if test -z "$choice_tz"; then
    stage_dec
    return
  fi
  # Mark this selected timezone for later use.
  export tgttimezone="$choice_tz"
  # Move on to the next stage.
  stage_inc
}
stage_rootpw() {
  # Only do this stage if rootpw is enabled in the osinstallgui configuration.
  if test "$OSINSTALLGUI_ROOTPW" = "1"; then
    # Ask the user for the root password. Again SC2155 applies here.
    local rootpw1
    rootpw1="$(yad_password "Root Password" "Please enter a new password for the system's root account. Leave the field empty to disable the root account (users willl still be able elevate using 'sudo').")"
    # Go back to the previous stage if the user backed out.
    if test $? -ne 0; then
      stage_dec
      return
    fi
    # Check if the root password field is empty.
    if test -z "$rootpw1"; then
      # Unsave the existing root password, in case the user went back a stage.
      export tgtrootpw=""
      # Skip ahead to the next stage immediately.
      stage_inc
      return
    fi
    # Now ask for the root password again, for verification purposes.
    local rootpw2
    rootpw2="$(yad_password "Root Password" "Please repeat the new password for the root account.")"
    test $? -eq 0 || return
    # Ensure the passwords match.
    if test "$rootpw1" != "$rootpw2"; then
      # Complain about this problem to the user.
      yad_message "Error" "The passwords you entered for the root account do not match."
      return
    fi
    # Password was set successfully. Save it for later.
    export tgtrootpw="$rootpw1"
  fi
  # Go to the next stage.
  stage_inc
}
stage_usersetup() {
  # Take note that SC2155 will apply for all input boxes in this section.
  # Ask the user for their full name. User can leave this blank if they wish.
  local fullname
  fullname="$(yad_input "User Setup" "Please enter the full name of the primary user. This field can be left blank if you'd prefer the new account to only be identifiable by its username.")"
  # Go back to the previous stage if the user backed out.
  if test $? -ne 0; then
    # Previous stage is one behind if root password is enabled, two if not.
    if test "$OSINSTALLGUI_ROOTPW" != "1"; then
      stage_dec
    fi
    stage_dec
    return
  fi
  # Filter input for only alphanumeric characters and spaces.
  fullname="$(echo "$fullname" | tr -cd '[:alnum:] [:space:]')"
  # Filter username for only the first word (i.e., forename), and lowercase.
  local username="$(echo "$fullname" | cut -d' ' -f1 | tr '[:upper:]' '[:lower:]')"
  # Behaviour for username input will depend on whether fullname was set.
  if test ! -z "$fullname"; then
    # Ask if the user is OK with the default username from fullname being used.
    if ! yad_prompt "User Setup" "You entered '$fullname' as your full name. The automatically generated username for this would be '$username'. Would you like to keep this default? Answer 'NO' if you wish to set a custom username."; then
      # Ask for the custom username.
      username="$(yad_input "User Setup" "Please enter the username you wish to use for $fullname's account. The username must NOT contain spaces, and must ONLY consist of alphanumeric characters. Leave it blank to use the default of '$username'.")"
      if test -z "$username"; then
        # This input was not mandatory because fullname was set, so revert it.
        username="$(echo "$fullname" | cut -d' ' -f1 | tr '[:upper:]' '[:lower:]')"
      else
        # Filter again for the newly entered username.
        username="$(echo "$username" | tr -cd '[:alnum:]' | tr '[:upper:]' '[:lower:]')"
      fi
    fi
  else
    # No fullname was specified, so username input will be mandatory.
    username="$(yad_input "User Setup" "Please enter the username you wish to use for the new account. The username must NOT contain spaces, and must ONLY consist of alphanumeric characters. Since you did not specify a full name, this field cannot be left blank.")"
    test $? -eq 0 || return
    if test -z "$username"; then
      # User didn't listen, make them face consequences.
      yad_message "Error" "The username field cannot be left blank because you did not previously specify a full name."
      return
    fi
    # Filter the input once again.
    username="$(echo "$username" | tr -cd '[:alnum:]' | tr '[:upper:]' '[:lower:]')"
  fi
  # Now set the global values and move on to the user password stage.
  export tgtusername="$username" tgtfullname="$fullname"
  stage_inc
}
stage_userpw() {
  # Once again, SC2155 will apply for the input boxes here, so take care.
  # Go back to the previous stage if the username was not set.
  if test -z "$tgtusername"; then
    stage_dec
    return
  fi
  # Ask the user for the password.
  local userpw1
  userpw1="$(yad_password "User Setup" "Please think of a secure password for the account '$tgtusername', and enter it here.")"
  # Go back to the previous stage if the user backed out.
  if test $? -ne 0; then
    stage_dec
    return
  fi
  # Ensure the field was not left blank.
  if test -z "$userpw1"; then
    # User didn't listen.
    yad_message "Error" "The password field cannot be left blank. You must think of a secure password for the account '$tgtusername'."
    return
  fi
  # Ensure the password is strong if cracklib-check is enabled and installed.
  if test "$OSINSTALLGUI_USER_PWSCORE" = "1" && which cracklib-check &>/dev/null; then
    # Invoke cracklib-check, capturing output and filtering only the reason.
    local userpwscore="$(echo "$userpw1" | cracklib-check | sed "s/$userpw1: //")"
    # If the password check failed due to it being insecure.
    if test "$userpwscore" != "OK"; then
      # userpwscore will contain the reason it failed the check.
      yad_message "Error" "The password you entered is not strong enough. This is because $userpwscore."
      return
    fi
  fi
  # Ask for the password again, for verification purposes.
  local userpw2
  userpw2="$(yad_password "User Setup" "Please repeat the new password for the account '$tgtusername'.")"
  # Ensure the passwords match.
  if test "$userpw1" != "$userpw2"; then
    yad_message "Error" "The passwords you entered for the account '$tgtusername' do not match."
    return
  fi
  # User password setup is done, now save and move on to the next stage.
  export tgtuserpw="$userpw1"
  stage_inc
}
stage_hostname() {
  # The default hostname will be in the format 'username-SystemModel'.
  # We will use dmidecode to find the model, if possible, or fallback to 'PC'.
  # We will also strip out non-alphanumeric/non-space/non-dash characters.
  # And then we will replace all spaces with dashes.
  # This is to be compliant with the hostname requirements.
  local defaulthostname="$tgtusername-$({ dmidecode -s system-product-name 2>/dev/null || echo "PC"; } | tr -cd '[:alnum:] [:space:] -' | sed 's/ /-/g')"
  # Collect the input using the default hostname as the default/placeholder.
  local hostname
  hostname="$(yad_input "Hostname" "Please enter your desired hostname which will identify this computer to the network." "$defaulthostname")"
  # Go back if the user backed out.
  if test $? -ne 0; then
    stage_dec
    return
  fi
  # Ensure the hostname is not empty.
  if test -z "$hostname"; then
    # Complain and try again.
    yad_message "Error" "The system hostname must not be left blank."
    return
  fi
  # Save our work and also filter like we did for the default hostname before.
  # This time we also need to truncate to 255 characters, due to the limit.
  export tgthostname="$(echo "$hostname" | tr -cd '[:alnum:] [:space:] -' | sed 's/ /-/g' | cut -c1-255)"
  # Move on to the next stage.
  stage_inc

}
stage_diskpar() {
  # New method which is designed to merge disk setup and partition setup.
  # It also allows for more flexibility, i.e., for multi-disk setups.
  # First, detect the disk containing the installation media, if any.
  local findlivepar="$(findmnt -no SOURCE -T "$OSINSTALLGUI_ROOTFS" 2>/dev/null)"
  # Only deal with it if it is a partition of a physical disk.
  if test ! -z "$findlivepar" && test -b "$findlivepar"; then
    # Find the source disk.
    local findlivedisk="$(lsblk -no PKNAME "$findlivepar" 2>/dev/null)"
    # Ensure it's a physical disk, again.
    if test ! -z "/dev/$findlivedisk" && test -b "/dev/$findlivedisk"; then
      # Set up this disk to be filtered out.
      local imdisk="$findlivedisk"
    fi
  fi
  # Detect all real disks, filtering out the installation media if needed.
  local disks=()
  readarray -t disks < <(find /sys/block -mindepth 1 -maxdepth 1 -type l ! -name dm-\* ! -name loop\* ! -name sr\* -exec basename {} \; | sort | grep -vx "$imdisk")
  # Throw an error if no disks were found.
  if test ${#disks[@]} -eq 0; then
    yad_message "Error" "No physical disks were found on your system. If your internal drive is failing to be detected, please ensure all of the following are true:\n\n1) Windows Bitlocker drive encryption is disabled.\n\n2) The 'SATA Mode' or 'Storage Mode' option in your BIOS is set to 'AHCI'.\n\n3) All options in your BIOS relating to 'RAID', 'Intel RST', 'Intel Optane', 'Intel Smart Storage', etc. are DISABLED.\n\nIf you need help, please look at the FAQ document in the osinstallgui source repository, and/or approach the support channel(s) of your distribution."
    # Go back to the main menu, since a reboot will probably be needed.
    export stage=0
    return
  fi
  # Set up the menu.
  local choice="$(yad_menu "Disk Setup" "Please choose how you would like to set up the disk(s) for installation." \
  "1" "Erase an entire disk and install $osname." \
  "2" "Select an existing partition to install $osname to." \
  "3" "Manually create and/or modify partitions before installing." \
  "4" "More information and clarification about this question.")"
  # Decide what to do based on the user's selection.
  case "${choice%%|*}" in
    "1")
      # Get details of each disk, for displaying in the disk selection menu.
      local diskentries=()
      for disk in "${disks[@]}"; do
        # Description includes both disk size (calculated in GiB) and disk model.
        # Both identifier and description get appended as expected by yad menu.
        diskentries+=("/dev/$disk" "$(($(cat "/sys/block/$disk/size") * 512 / 1073741824))GiB ⎯ $(cat "/sys/block/$disk/device/model")")
      done
      # Now display the entries to the user, so they can choose which disk to use.
      local choice="$(yad_menu "Disk Setup" "Please select the disk to erase and use for the installation." "${diskentries[@]}")"
      # Restart to the top menu of this function if the user backed out.
      test ! -z "$choice" || return
      # Set up the selection.
      local diskselection="${choice%%|*}"
      # Get the list of mounted partitions (if any), sorted by mount depth.
      local mountedparts="$(mount | grep "$diskselection" | cut -d' ' -f1,3 | sort -rk2 | cut -d' ' -f1)"
      # Allow us to try and unmount them if any exist.
      if test ! -z "$mountedparts"; then
        # Let the user decide if they want to try to unmount the partitions.
        if yad_prompt "Warning" "The selected disk appears to have mounted partitions. In order to use it for the installation, all partitions must first be unmounted. Do you want this program to try and unmount them for you?"; then
          # Try to unmount each partition. Sort was done because we can't use -R.
          for part in $mountedparts; do
            sync; umount "$part" &>>/dev/null
            sync; swapoff "$part" &>>/dev/null
          done
          # Check if there are still mounted partitions.
          if mount | grep -q "$diskselection"; then
            # Complain and return.
            yad_message "Error" "This program was unable to unmount all partitions on the disk. Please try to unmount them manually, or alternatively select a different disk for the installation."
            return
          fi
        else
          # User didn't even let us try, what can we do?
          return
        fi
      fi
      # Ask if btrfs should be used, if supported and enabled in configuration.
      if test "$OSINSTALLGUI_ALLOW_BTRFS" = "1" && which mkfs.btrfs &>/dev/null && yad_prompt "Erase Disk" "Would you like to use btrfs for the root partition? This is recommended, unless you have a specfic reason to prefer the traditional ext4."; then
        local btrfsuse=1
      else
        local btrfsuse=0
      fi
      # Ask if the user wants swap space.
      if yad_prompt "Erase Disk" "Swap is a reserved area on the disk which can act as an emergency RAM backup in case the system RAM becomes full. Would you like to make use of a swap file?"; then
        # Ask how much swap space the user wants.
        local choiceswapsize="$(yad_menu "Erase Disk" "Please select the size you wish the swap file to be. Be advised that higher sizes will reduce the amount of free space you have after installation." \
        "2G" "Default" \
        "4G" "" \
        "8G" "" \
        "16G" "")"
        local swapsize="${choiceswapsize%%|*}"
        # If the user backed out of the menu, use the default value.
        if test -z "$swapsize"; then
          swapsize="2G"
        fi
      fi
      # Final warning before fully erasing the disk.
      yad_prompt "Erase Disk" "WARNING! Any existing data on the disk $diskselection is now going to be PERMANENTLY DELETED. This action is IRREVERSIBLE. Are you sure you want to continue?" || return
      # Wipe filesystems, overwrite MBR (if any), and erase GPT (if any).
      write_log "Erasing the disk $diskselection."
      sync; wipefs -af "$diskselection" &>>"$log"
      sync; dd if=/dev/zero of="$diskselection" bs=1M count=10 &>>"$log"
      sync; sgdisk -Z "$diskselection" &>>"$log"
      write_log "Finished erasing the disk $diskselection."
      # Sync changes with the kernel.
      sync; partprobe
      # Decide which partitions to make depending on boot mode and swap choice.
      if test $efimode -eq 1; then
        # UEFI.
        local operations='g\nn\n\n\n+500M\nt\n1\nn\n\n\n\nw\n'
      else
        # Legacy BIOS.
        local operations='o\nn\n\n\n\n\nw\n'
      fi
      # Partition the disk.
      write_log "Partitioning the disk $diskselection using fdisk."
      echo -e "$operations" | fdisk "$diskselection" &>>"$log"
      if test $? -ne 0; then
        # OH NO! It failed, this could be bad.
        write_log "Failed to partition the disk $diskselection using fdisk."
        yad_message "Error" "Failed to partition the disk $diskselection (fdisk returned an unsuccessful exit code). A log file can be found at $log."
        return
      fi
      # Get a list of all the partitions which were just created.
      local createdparts=()
      readarray -t createdparts < <(lsblk -lnp "$diskselection" | grep part | cut -d' ' -f1)
      # Ensure the disk was partitioned correctly by counting the partitions.
      if test $efimode -eq 1 && test -z "${createdparts[1]}"; then
        # EFI configuration needs 2 partitions.
        yad_message "Error" "Failed to partition the disk $diskselection (the operation didn't create all needed partitions). A log file can be found at $log."
        return
      elif test -z "${createdparts[0]}"; then
        # No partitions at all - this would be an error in all cases.
        yad_message "Error" "Failed to partition the disk $diskselection (the operation didn't create any partitions). A log file can be found at $log."
        return
      fi
      # Find the label for the root partition.
      if test "$osname" = "An OS without a name"; then
        # Use 'Linux' if it has no name.
        local rootlabel="Linux"
      else
        # Use the first word in the OS name.
        local rootlabel="$(echo "$osname" | cut -d' ' -f1)"
      fi
      # Format partitions.
      if test $btrfsuse -eq 1; then
        helper_format "${createdparts[-1]}" btrfs "$rootlabel"
        if test $? -ne 0; then
          yad_message "Error" "Failed to format the root filesystem ${createdparts[-1]} as btrfs. A log file can be found at $log."
          return
        fi
      else
        helper_format "${createdparts[-1]}" ext4 "$rootlabel"
        if test $? -ne 0; then
          yad_message "Error" "Failed to format the root filesystem ${createdparts[-1]} as ext4. A log file can be found at $log."
          return
        fi
      fi
      if test $efimode -eq 1; then
        helper_format "${createdparts[0]}" vfat "EFI SYSTEM"
        if test $? -ne 0; then
          yad_message "Error" "Failed to format the EFI System Partition ${createdparts[0]} as vfat. A log file can be found at $log."
          return
        fi
      fi
      # Set up the global variables, now we are done with this process.
      export tgtdisk="$diskselection"
      export tgtroot="${createdparts[-1]}"
      test $efimode -ne 1 || export tgtefi="${createdparts[0]}"
      # Save the swap size.
      export tgtswap="$swapsize"
      # Move on to the next stage.
      stage_inc
      ;;
    "2")
      # Get a list of every partition on every disk.
      local partentries=()
      for disk in "${disks[@]}"; do
        # List partitions on this disk.
        local individualdiskparts=()
        readarray -t individualdiskparts < <(lsblk -lnp "/dev/$disk" | grep part | cut -d' ' -f1)
        # Go through each of these partitions and add them to the top entry.
        for part in "${individualdiskparts[@]}"; do
          # Get partition details.
          local partsize="$(lsblk -lnp "$part" | xargs | cut -d' ' -f4)"
          local partfs="$(blkid -o value -s TYPE "$part")"
          local partlabel="$(blkid -o value -s LABEL "$part")"
          # Unknown filesystem would be blank by default.
          if test -z "$partfs"; then
            partfs="unknown"
          fi
          # Add the entry, description is based on whether it is labelled or not.
          if test ! -z "$partlabel"; then
            partentries+=("$part" "$partsize ⎯ $partfs ⎯ $partlabel")
          else
            partentries+=("$part" "$partsize ⎯ $partfs")
          fi
        done
      done
      # Throw an error and go back if there are no partitions on any disk.
      if test ${#partentries[@]} -eq 0; then
        yad_message "Error" "No partitions were found on any disk. Please choose the 'Erase Disk' option instead, or alteratively use the 'Manual Partitioning' option to create the required partitions on the disk(s)."
        return
      fi
      # Ask which root partition to use.
      local choicerootpar="$(yad_menu "Partition Setup" "Please select the partition you wish to use for the root filesystem. It will be formatted, and any existing data on it will be deleted." "${partentries[@]}")"
      # Go back if the user backed out.
      test ! -z "$choicerootpar" || return
      # Filter yad return value to get the selection.
      local rootparselection="${choicerootpar%%|*}"
      # Check if the partition is mounted.
      if mount | grep -q "$rootparselection"; then
        # Unmount if needed.
        if yad_prompt "Warning" "The selected partition appears to be mounted. It must be unmounted before it can be used for the installation of $osname. Would you like this program to try unmounting it for you?"; then
          # Try to unmount.
          sync; umount "$rootparselection" &>>/dev/null
          sync; swapoff "$rootparselection" &>>/dev/null
          # Check if it is still mounted.
          if mount | grep -q "$rootparselection"; then
            yad_message "Error" "This program was unable to unmount the selected partition. Please try to unmount it manually, or alternatively select a different partition."
            return
          fi
        else
          # Didn't even get a chance to try.
          return
        fi
      fi
      # Ask whether they want btrfs or ext4, if allowed.
      if test "$OSINSTALLGUI_ALLOW_BTRFS" = "1" && which mkfs.btrfs &>/dev/null && yad_prompt "Partition Setup" "Would you like to use btrfs for the root partition? This is recommended, unless you have a specfic reason to prefer the traditional ext4."; then
        local btrfsuse=1
      else
        local btrfsuse=0
      fi
      # Prompt for selection of an EFI partition if we are in UEFI mode.
      if test $efimode -eq 1; then
        # Show an information message.
        yad_message "Partition Setup" "Your system is booted in UEFI mode. A small FAT32 (vfat) partition of around 100MiB-500MiB, separate to the root partition, must therefore exist on the disk, to be used for the bootloader installation. It can be shared between all OSes in a dual-boot setup (without needing to be re-formatted), and it may be on a different disk to the one containing the selection for the root partition. If you need help with this, please refer to the FAQ document in the osinstallgui source repository."
        # Ask which EFI partition to use.
        local choiceefipar="$(yad_menu "Partition Setup" "Please select the partition you wish to use for the EFI system partition. It must differ from the selection for the root partition." "${partentries[@]}")"
        # Go back if the user backed out.
        test ! -z "$choiceefipar" || return
        # Filter yad return value to get the selection.
        local efiparselection="${choiceefipar%%|*}"
        # The root partition and EFI partition cannot be the same.
        if test "$efiparselection" = "$rootparselection"; then
          # Did the user not even listen to what they were told?
          yad_message "Error" "The selected EFI system partition $efiparselection must NOT be the same as the root partition $rootparselection. Please select a different partition."
          return
        fi
        # If the selected partition is not vfat, then we need to format it.
        local efiformat=0
        if test "$(blkid -o value -s TYPE "$efiparselection")" != "vfat"; then
          if yad_prompt "Partition Setup" "The selected EFI system partition $efiparselection is not formatted as vfat (FAT32). It will therefore be formatted by this program, and any existing data on it will be deleted. Is this OK?"; then
            # Mark that we need to format this.
            efiformat=1
          else
            # We cannot use it if the user doesn't want to format it.
            return;
          fi
        fi
      fi
      # Ask if the user wants swap space, same as in erase disk option.
      if yad_prompt "Partition Setup" "Swap is a reserved area on the disk which can act as an emergency RAM backup in case the system RAM becomes full. Would you like to make use of a swap file?"; then
        # Ask how much swap space the user wants.
        local choiceswapsize="$(yad_menu "Erase Disk" "Please select the size you wish the swap file to be. Be advised that higher sizes will reduce the amount of free space you have after installation." \
        "2G" "Default" \
        "4G" "" \
        "8G" "" \
        "16G" "")"
        local swapsize="${choiceswapsize%%|*}"
        # If the user backed out of the menu, use the default value.
        if test -z "$swapsize"; then
          swapsize="2G"
        fi
      fi
      # Determine the label for the root filesystem.
      if test "$osname" = "An OS without a name"; then
        # Use 'Linux' if it has no name.
        local rootlabel="Linux"
      else
        # Use the first word in the OS name.
        local rootlabel="$(echo "$osname" | cut -d' ' -f1)"
      fi
      # Final warning before we format.
      local formatinfo=""
      # Whether or not EFI partition needs formatting.
      if test $efiformat -eq 1; then
        formatinfo+="\n$efiparselection as vfat"
      fi
      # Whether or not the root partition will be formatted as btrfs or ext4.
      if test $btrfsuse -eq 1; then
        formatinfo+="\n$rootparselection as btrfs"
      else
        formatinfo+="\n$rootparselection as ext4"
      fi
      # Display the message, go back if the user backs out.
      yad_prompt "Partition Setup" "The following partition(s) are now going to be formatted, and any existing data will be PERMANENTLY DELETED. This action is IRREVERSIBLE. Are you sure you want to proceed?\n\n$formatinfo" || return
      # Format the partitions now.
      if test $btrfsuse -eq 1; then
        helper_format "$rootparselection" btrfs "$rootlabel"
        if test $? -ne 0; then
          yad_message "Error" "Failed to format the root filesystem $rootparselection as btrfs. A log file can be found at $log."
          return
        fi
      else
        helper_format "$rootparselection" ext4 "$rootlabel"
        if test $? -ne 0; then
          yad_message "Error" "Failed to format the root filesystem $rootparselection as ext4. A log file can be found at $log."
          return
        fi
      fi
      if test $efimode -eq 1 && test $efiformat -eq 1; then
        helper_format "$efiparselection" vfat "EFI SYSTEM"
        if test $? -ne 0; then
          yad_message "Error" "Failed to format the EFI System Partition $efiparselection as vfat. A log file can be found at $log."
          return
        fi
      fi
      # Save the partition selections for the rest of the installation.
      export tgtroot="$rootparselection" tgtefi="$efiparselection"
      # Save the swap size.
      export tgtswap="$swapsize"
      # Proceed to the next stage.
      stage_inc
      ;;
    "3")
      # Launch GParted as an external program, if it is available.
      if which gparted &>/dev/null; then
        yad_message "Manual Partitioning" "The GParted graphical partitioning program will be launched. Once you have finished partitioning with this program, close the program, then the installation process will continue."
        write_log "Launching GParted as an external program."
        gparted "$tgtdisk" &>>"$log"
        write_log "Execution of GParted as an external program finished."
        return
      else
        yad_message "Error" "Unable to start manual partitioning because GParted does not appear to be installed on the system. You may still be able to use alternative software outside of this installer, to be able to manually partition the disk."
        return
      fi
      ;;
    "4")
      # Display a help message.
      yad_message "Disk Setup" "$osname needs to be installed onto a physical storage disk on your system. This installer provides several options to choose from for disk setup, depending on your needs.\n\nChoose 1 if $osname is the only (or first) OS to be installed on this machine. This will erase the entire selected disk and install $osname to it.\n\nChoose 2 if you are dual-booting or have custom partitioning you don't want to overwrite. This option lets you select an existing partition on a disk, to install $osname to. On UEFI systems, it also allows selecting an EFI partition on a different disk, for multi-disk setups.\n\nChoose 3 to manually create/modify partitions before proceeding."
      ;;
    "")
      # Go back to the previous stage.
      stage_dec
      ;;
  esac
}
stage_mount() {
  # Ensure we know which partitions we are working with.
  if test -z "$tgtroot"; then
    # Step back a stage, because we don't know what we are working with.
    stage_dec
    return
  fi
  sync
  # Try to mount the root partition, ready for installation.
  if ! helper_mount "$tgtroot" "$tgtpath"; then
    # Complain and go back to the disk setup stage.
    yad_message "Error" "Unable to mount the root partition $tgtroot. The installation cannot continue. A log file can be found at $log."
    # TODO: Give the user a choice to either retry or go back to diskpar stage.
    stage_dec
    return
  fi
  # Mount the EFI partition if needed.
  if test $efimode -eq 1 && ! helper_mount "$tgtefi" "$tgtpath/boot/efi"; then
    yad_message "Error" "Unable to mount the EFI system partition $tgtroot. The installation cannot continue. A log file can be found at $log."
    stage_dec
    return
  fi
  # If we got through without issues, then lets begin the installation.
  stage_inc
}
stage_swapsetup() {
  # Additional stage to handle setting up the swap file.
  # Do nothing if we are not using swap space.
  if test -z "$tgtswap"; then
    stage_inc
    return
  fi
  # A different setup is needed depending on which filesystem we are using.
  write_log "Trying to create and activate a $tgtswap swapfile."
  if test "$(blkid -o value -s TYPE "$tgtroot")" = "btrfs"; then
    # The btrfs program provides a command which does all the needed setup.
    btrfs -v filesystem mkswapfile --size "$tgtswap" "$tgtpath"/swapfile &>>"$log"
  else
    # We need to manually create it for ext4.
    {
      # Sync between every operation for robustness.
      sync; fallocate -vl "$tgtswap" "$tgtpath"/swapfile
      sync; chmod -v 0600 "$tgtpath"/swapfile
      sync; mkswap "$tgtpath"/swapfile
    } &>>"$log"
  fi
  # Try to activate the newly created swapfile.
  sync
  if ! swapon "$tgtpath"/swapfile &>>"$log"; then
    # Unable to create and activate the swap file, remove if it needed.
    rm -fv "$tgtpath"/swapfile &>>"$log"
    # Display the message.
    write_log "Failed to create and activate a $tgtswap swapfile."
    yad_message "Warning" "The $tgtswap swapfile could not be created and activated. The installation will continue without swap space. A log file can be found at $log."
    # Change the global swap space variable to disabled, so it won't be used.
    export tgtswap=""
  else
    write_log "Successfully created and activated a $tgtswap swapfile."
  fi
  # Go to the next stage.
  stage_inc
  return
}
stage_installation() {
  # This is where the fun happens.
  # One last check to ensure the partitions are mounted before continuing.
  sync
  if ! mount | grep "$tgtroot" &>/dev/null || { test $efimode -eq 1 && ! mount | grep "$tgtefi" &>/dev/null; }; then
    # Return to the mounting stage.
    stage_dec
    return
  fi
  # Determine whether we are using a squashfs or tar image.
  if test "$(file -b "$OSINSTALLGUI_ROOTFS" | cut -d' ' -f1)" = "Squashfs"; then
    # Unsquash the image.
    write_log "Unsquashing $OSINSTALLGUI_ROOTFS to $tgtpath."
    # Unsquash with percentage and pipe to yad for progress bar.
    unsquashfs -f -q -percentage -d "$tgtpath" "$OSINSTALLGUI_ROOTFS" 2>>"$log" | yad --progress --title="Installation ⎯ $inv" --text="The installation of $osname is in progress. Please be patient while the system is being installed." --percentage=0 --auto-close --no-buttons --no-escape --width=600 --height=100
    if test $? -ne 0; then
      write_log "Failed to unsquash $OSINSTALLGUI_ROOTFS to $tgtpath."
      yad_message "Error" "The installation process did not complete successfully (unsquashfs operation failed). A log file can be found at $log."
      # Return to the main menu because reboot will probably be needed.
      export stage=0
      return
    fi
    write_log "Successfully unsquashed $OSINSTALLGUI_ROOTFS to $tgtpath."
  else
    # Untar the image.
    write_log "Untarring $OSINSTALLGUI_ROOTFS to $tgtpath."
    # TODO: Make a percentage progress bar for tar, not just squashfs.
    tar -xpf "$OSINSTALLGUI_ROOTFS" -C "$tgtpath" &>>"$log"
    if test $? -ne 0; then
      write_log "Failed to untar $OSINSTALLGUI_ROOTFS to $tgtpath."
      yad_message "Error" "The installation process did not complete successfully (tar operation failed). A log file can be found at $log."
      # Return to the main menu because reboot will probably be needed.
      export stage=0
      return
    fi
    write_log "Successfully untarred $OSINSTALLGUI_ROOTFS to $tgtpath."
  fi
  sync
  # Now move to the post installation stage.
  stage_inc
}
stage_postinstall() {
  # This stage only exists for running the specified rootfs cleanup script.
  # Only need to do anything if the cleanup script was set in the config.
  if test ! -z "$OSINSTALLGUI_CLEANUP_CMD"; then
    # Ensure the file is executable.
    if test ! -x "$tgtpath/$OSINSTALLGUI_CLEANUP_CMD"; then
      # Warn about the problem, even though it is not fatal.
      yad_message "Error" "Cannot run the rootfs cleanup script because it does not exist or is not executable. This stage of the installation will therefore be skipped, which may cause the newly installed system to be tainted."
      # Move on to the next stage (system configuration) immediately.
      stage_inc
      return
    fi
    # Run the script.
    write_log "Running the rootfs cleanup script $OSINSTALLGUI_CLEANUP_CMD."
    # Try to run the script.
    if ! helper_chroot_advanced "$tgtpath" "$OSINSTALLGUI_CLEANUP_CMD"; then
      # Warn about it exiting unsuccessfully. But again still continue.
      write_log "The rootfs cleanup script did not complete successfully."
      yad_message "Error" "The rootfs cleanup script did not complete successfully. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully ran the rootfs cleanup script $OSINSTALLGUI_CLEANUP_CMD."
    fi
  fi
  # Go to the next stage, which will be the full system configuration.
  stage_inc
}
stage_systemconfig() {
  # This stage is for configuring the system after the installation.
  # Set up a progress bar using coproc, which we will update ourselves.
  coproc systemconfigprogress { yad --progress --title="Installation ⎯ $inv" --text="Configuring the system, please be patient." --percentage=0 --auto-close --auto-kill --no-buttons --no-escape --width=600 --height=100; }
  # Generate the fstab file.
  write_log "Generating /etc/fstab for the target system."
  # Do all echos in a block and only write at the end, as required by SC2129.
  {
    echo "# This /etc/fstab was automatically generated by osinstallgui."
    echo "# Do not modify unless you know what you are doing."
    echo "# Any mistakes in this file could prevent the system from booting."
    # Root filesystem fstab entry.
    echo "UUID=$(blkid -o value -s UUID "$tgtroot") / $(blkid -o value -s TYPE "$tgtroot") defaults 1 1"
    # EFI system partition fstab entry.
    if test ! -z "$tgtefi"; then
      echo "UUID=$(blkid -o value -s UUID "$tgtefi") /boot/efi vfat umask=0077 0 2"
    fi
    # Swapfile fstab entry.
    if test ! -z "$tgtswap"; then
      echo "/swapfile none swap sw 0 0"
    fi
  } > "$tgtpath"/etc/fstab
  write_log "Finished generation of /etc/fstab for the target system."
  echo "14" >&"${systemconfigprogress[1]}"
  # Prepare the locale for generation by uncommenting the line in the file.
  sed -i "s/#$tgtlocale/$tgtlocale/" "$tgtpath/$OSINSTALLGUI_LOCALES_FILE"
  # Generate the locales using a chroot environment.
  write_log "Generating locales in chroot using $OSINSTALLGUI_LOCALES_CMD."
  if ! helper_chroot_advanced "$tgtpath" "$OSINSTALLGUI_LOCALES_CMD"; then
    # Warn about it being unsuccessful.
    write_log "$OSINSTALLGUI_LOCALES_CMD failed to generate locales."
    yad_message "Error" "The locales could not be successfully generated on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found $log."
  else
    write_log "$OSINSTALLGUI_LOCALES_CMD successfully generated locales."
  fi
  # Set up the locale configuration file.
  echo "LANG=$tgtlocale" > "$tgtpath"/etc/locale.conf
  # Set up the keymap configuration file.
  echo "KEYMAP=$tgtkeymap" > "$tgtpath"/etc/vconsole.conf
  # Set up the X11 keymap configuration file.
  local layoutx11 variantx11
  if echo "$tgtx11key" | grep -q _; then
    # Layout and variant.
    layoutx11="$(echo "$tgtx11key" | cut -d_ -f1)"
    variantx11="$(echo "$tgtx11key" | cut -d_ -f2-)"
  else
    # Layout only.
    layoutx11="$tgtx11key"
  fi
  install -dm755 "$tgtpath"/etc/X11/xorg.conf.d
  {
    echo "# This file was automatically generated by osinstallgui."
    echo "# It sets the default X11 keymap, chosen when this OS was installed."
    echo ""
    echo "Section \"InputClass\""
    echo "    Identifier \"system-keyboard\""
    echo "    MatchIsKeyboard \"on\""
    echo "    Option \"XkbLayout\" \"$layoutx11\""
    echo "    Option \"XkbVariant\" \"$variantx11\""
    echo "    Option \"XkbModel\" \"pc105\""
    echo "    Option \"XkbOptions\" \"\""
    echo "EndSection"
  } > "$tgtpath"/etc/X11/xorg.conf.d/00-keyboard.conf
  echo "28" >&"${systemconfigprogress[1]}"
  # Set up the timezone.
  write_log "Setting timezone of target system to $tgttimezone."
  ln -sfv /usr/share/zoneinfo/"$tgttimezone" "$tgtpath"/etc/localtime  &>>"$log"
  write_log "Timezone of target system successfully set to $tgttimezone."
  # Update the hardware clock.
  # TODO: Allow localtime instead of UTC, for some distros which prefer that.
  write_log "Updating hardware clock in chroot environment."
  if ! helper_chroot_advanced "$tgtpath" /usr/bin/env hwclock -v --systohc; then
    # Warn about it being unsuccessful.
    write_log "Failed to update hardware clock in chroot environment."
    yad_message "Error" "The hardware clock could not be updated correctly on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found $log."
  else
    write_log "Successfully updated hardware clock in chroot environment."
  fi
  echo "42" >&"${systemconfigprogress[1]}"
  # Set up the root password, if a root password was specified.
  if test ! -z "$tgtrootpw"; then
    write_log "Setting the root password using chpasswd."
    if ! echo "root:$tgtrootpw" | chpasswd -R "$tgtpath" -c YESCRYPT &>>"$log"; then
      # Warn about it being unsuccessful.
      write_log "Failed to set the root password."
      yad_message "Error" "The root password could not be set on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully set the root password."
    fi
  fi
  echo "57" >&"${systemconfigprogress[1]}"
  # Set up the new primary user account - depending on whether fullname is set.
  if test ! -z "$tgtfullname"; then
    # Fullname is set.
    write_log "Creating account for $tgtusername ($tgtfullname) using useradd."
    if ! useradd -R "$tgtpath" -c "$tgtfullname" -G "$OSINSTALLGUI_ADMIN_GROUP" -ms "$OSINSTALLGUI_USER_SHELL" "$tgtusername" &>>"$log"; then
      # Warn about it being unsuccessful.
      write_log "Failed to create account for $tgtusername ($tgtfullname)."
      yad_message "Error" "The primary user account '$tgtusername' ($tgtfullname) could not be created on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully created account for $tgtusername ($tgtfullname)."
    fi
  else
    # No fullname is set.
    write_log "Creating account for $tgtusername using useradd."
    if ! useradd -R "$tgtpath" -G "$OSINSTALLGUI_ADMIN_GROUP" -ms "$OSINSTALLGUI_USER_SHELL" "$tgtusername" &>>"$log"; then
      # Warn about it being unsuccessful.
      write_log "Failed to create account for $tgtusername."
      yad_message "Error" "The primary user account '$tgtusername' could not be created on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully created account for $tgtusername."
    fi
  fi
  echo "71" >&"${systemconfigprogress[1]}"
  # Set the password for the user account.
  write_log "Setting password for $tgtusername using chpasswd."
  if ! echo "$tgtusername:$tgtuserpw" | chpasswd -R "$tgtpath" -c YESCRYPT &>>"$log"; then
    # Warn about it being unsuccessful.
    write_log "Failed to set password for $tgtusername."
    yad_message "Error" "The password for '$tgtusername' could not be set on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
  else
    write_log "Successfully set password for $tgtusername"
  fi
  echo "85" >&"${systemconfigprogress[1]}"
  # Set the hostname for the system.
  write_log "Setting the system hostname to $tgthostname."
  # Need to set in both /etc/hostname and /etc/hosts.
  # For the latter, we match the line beginning with 127.0.1.1 and replace it.
  if ! { echo "$tgthostname" > "$tgtpath"/etc/hostname && sed -i "s/^127\.0\.1\.1 .*/127.0.1.1 $tgthostname/" "$tgtpath"/etc/hosts; }; then
    # Warn about it being unsuccessful.
    write_log "Failed to set the system hostname to $tgthostname."
    yad_message "Error" "The hostname for the system could not be set on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
  else
    write_log "Successfully set the system hostname to $tgthostname."
  fi
  echo "100" >&"${systemconfigprogress[1]}"
  # Proceed to the next stage (initramfs generation).
  stage_inc
}
stage_initramfs() {
  # Generate an initramfs for the target system.
  write_log "Generating an initramfs for the target system."
  # Pipe to yad to show something is happening (because it can take a while).
  # Without this, the program would appear closed which could confuse users.
  {
    # Won't be any visual progress indicator, but still try to log output.
    helper_chroot_advanced "$tgtpath" $OSINSTALLGUI_INITRAMFS_CMD
    # Write command status into a file on disk, else it will be lost by pipe.
    echo "$?" > "$workdir"/.status_initramfs
    # Tell yad that it is now at 100%, to finish the dialog.
    echo "100"
  } | yad --progress --title="Installation ⎯ $inv" --text="Generating an initramfs for the target system, please wait (progress will display 0% until complete)." --percentage=0 --auto-close --no-buttons --no-escape --width=600 --height=100
  if test "$(cat "$workdir"/.status_initramfs 2>&1)" != "0"; then
    # OH NO! Something went horribly wrong. Report the error.
    write_log "Failed to generate an initramfs for the target system."
    yad_message "Error" "Failed to generate an initramfs for the target system. The installation process will continue anyway, however it is VERY LIKELY that the target system will FAIL TO BOOT, and manual intervention will be needed after the installation. A log file can be found at $log."
  else
    write_log "Successfully generated an initramfs for the target system."
  fi
  # Proceed to the penultimate stage (bootloader setup).
  stage_inc
}
stage_bootloader() {
  # Install the bootloader on the target system.
  # In both cases, the '--target' option is now explicitly specified.
  # Otherwise some buggy BIOSes will default to a target unsupported by GRUB.
  local grub_args
  if test $efimode -eq 1; then
    # UEFI mode.
    grub_args+="--target=x86_64-efi"
    # Ask the user if they want to install in internal or removable mode.
    # We have now switched to a menu to improve user-friendliness.
    local choice="$(yad_menu "Bootloader" "Which type of disk are you installing $osname to?" "Internal" "Internal SSD or hard drive (default)." "Removable" "Portable HDD/SSD or USB flash drive." "Help" "More detail about this question.")"
    choice="${choice%%|*}"
    if test -z "$choice" || test "$choice" = "Help"; then
      # Show the help message.
      yad_message "Bootloader" "The GRUB UEFI bootloader can be installed in either 'Internal' or 'Removable' mode, to make it easier to boot depending on which type of disk you are installing $osname to.\n\nChoose 'Internal' for all internal disks or any disks that are intended to remain connected to the same system. This includes for dual-booting.\n\nChoose 'Removable' if you are installing $osname to a removable drive, such a portable HDD/SSD or a USB flash drive. This will ensure the drive can be booted on any system, and is not locked to the system it was installed from.\n\nPlease consult the FAQ in the osinstallgui source repository for more information, as well as the rationale behind the inclusion of this option in osinstallgui."
      # Start this choice again.
      return
    elif test "$choice" = "Removable"; then
      # Add the --removable flag to the arguments for grub-install.
      grub_args+=" --removable"
    fi
  else
    # Legacy BIOS mode - the disk has to be explicitly passed as an argument.
    grub_args+="--target=i386-pc $tgtdisk"
  fi
  # Try to install the bootloader.
  write_log "Trying to install bootloader using 'grub-install $grub_args'."
  # Fake progress bar, but at least a way to inform the user somehow.
  {
    # GRUB installation step.
    helper_chroot_advanced "$tgtpath" /usr/bin/env grub-install $grub_args
    echo "$?" > "$workdir"/.status_grub_a
    # Tell yad that we are half done.
    echo "50"
    # GRUB configuration step.
    helper_chroot_advanced "$tgtpath" /usr/bin/env grub-mkconfig -o /boot/grub/grub.cfg
    echo "$?" > "$workdir"/.status_grub_b
    # Now tell yad that we are done.
    echo "100"
  } | yad --progress --title="Installation ⎯ $inv" --text="Installing the GRUB bootloader, please be patient." --percentage=0 --auto-close --no-buttons --no-escape --width=600 --height=100
  if test "$(cat "$workdir"/.status_grub_a 2>&1)" != "0" || test "$(cat "$workdir"/.status_grub_b 2>&1)" != "0"; then
    # Something went wrong, complain about the problem.
    write_log "Bootloader installation using 'grub-install $grub_args' failed."
    yad_message "Error" "The GRUB bootloader installation failed. Manual intervention will likely be needed to correct this problem and make your system bootable. A log file can be found at $log."
  else
    write_log "Bootloader installation using 'grub-install $grub_args' succeeded."
  fi
  # Go to the final stage.
  stage_inc
}
stage_finish() {
  # Deactivate the swapfile, if needed.
  if test -e "$tgtpath"/swapfile && swapon --show=NAME | grep -q "^$tgtpath/swapfile$"; then
    write_log "Trying to deactivate the swapfile."
    swapoff "$tgtpath"/swapfile &>>"$log"
    write_log "Finished deactivating the swapfile (hopefully)."
  fi
  # Unmount all filesystems.
  write_log "Unmounting all filesystems..."
  helper_umount "$tgtpath"
  write_log "Finished unmounting all filesystems (hopefully)."
  # Show finishing message.
  if yad_prompt "Installation" "The installation of $osname has finished. Select 'YES' to shut down your system now, so you can restart into the new installation. Select 'NO' if, instead, you'd like to continue testing the live environment. In any case, remember to remove the installation media, to ensure you boot into the new installation as opposed to the live environment."; then
    shutdown -h now
  fi
  # Exit the thing (stage will be less than 0 so the main loop will stop).
  export stage=-1
}

# Get a timestamp for naming logs and temporary files/directories.
export stamp="$(date "+%Y%m%d%H%M%S%N")"

# Determine our host's name.
export osname="$(grep -sm1 "^PRETTY_NAME=" /etc/os-release | cut -d= -f2 | sed 's/"//g')"
if test -z "$osname"; then
  export osname="an OS with no name"
fi

# Create a temporary directory for us to use.
export workdir="/tmp/osinstallgui$stamp"
mkdir -p "$workdir"

# Set up the log file.
export log="$workdir/osinstallgui.log"
touch "$log"

# Ensure we are running as root.
if test $EUID -ne 0; then
  die "$inv must be run as root (use 'sudo')."
fi

# Ensure the global config file exists, and source it if it does.
if test -f "@@CONFPATH@@"/osinstallgui.conf; then
  write_log "Sourcing config file '@@CONFPATH@@/osinstallgui.conf'."
  . "@@CONFPATH@@"/osinstallgui.conf &>>"$log" || true
  write_log "Sourced config file '@@CONFPATH@@/osinstallgui.conf'."
else
  write_log "Config file '@@CONFPATH/osinstallgui.conf' does not exist."
fi

# Do not proceed if any mandatory configuration options are not set.
for val in "$OSINSTALLGUI_ROOTFS" "$OSINSTALLGUI_INITRAMFS_CMD" "$OSINSTALLGUI_LOCALES_CMD" "$OSINSTALLGUI_LOCALES_FILE" "$OSINSTALLGUI_ADMIN_GROUP" "$OSINSTALLGUI_USER_SHELL"; do
  if test -z "$val"; then
    die "$inv cannot run due to one or more missing config value(s)."
  fi
done

# Set up defaults for configuration values which are not mandatory.
test ! -z "$OSINSTALLGUI_ALLOW_BTRFS" || OSINSTALLGUI_ALLOW_BTRFS=1
test ! -z "$OSINSTALLGUI_KEYMAPS_SYSTEMD" || OSINSTALLGUI_KEYMAPS_SYSTEMD=1
test ! -z "$OSINSTALLGUI_KEYMAPS_LOCATION" || OSINSTALLGUI_KEYMAPS_LOCATION="/usr/share/keymaps"
test ! -z "$OSINSTALLGUI_ROOTPW" || OSINSTALLGUI_ROOTPW=1
test ! -z "$OSINSTALLGUI_USER_PWSCORE" || OSINSTALLGUI_USER_PWSCORE=0

# Ensure data files exist.
if test ! -e "@@CONFPATH@@"/data/locales.desc; then
  warn "$inv could not find the file '@@CONFPATH@@/data/locales.desc'."
  warn "$inv will therefore display all locales with description 'UNKNOWN'."
fi
if test ! -e "@@CONFPATH@@"/data/keymaps.desc; then
  warn "$inv could not find the file '@@CONFPATH@@/data/keymaps.desc'."
  warn "$inv will therefore display all keymaps with description 'UNKNOWN'."
fi

# Check dependencies - ordered by importance and when they are used.
check_dep yad
check_dep xkbcli libxkbcommon
check_dep yq
check_dep sgdisk gptfdisk
check_dep parted
check_dep partprobe parted
check_dep mkfs.ext4 e2fsprogs
check_dep mkfs.fat dosfstools
check_dep unsquashfs squashfs-tools

# Disk and partition variables need to be accessed by the whole program.
export tgtdisk="" tgtroot="" tgtefi="" tgtswap=""

# Other global setup variables which need to be accessed by the whole program.
export tgtlocale="" tgtkeymap="" tgtx11key="" tgttimezone="" tgtrootpw="" tgtusername="" tgtfullname="" tgtuserpw="" tgthostname=""

# Set up the mount directory for the target system.
export tgtpath="$workdir/target"
mkdir -p "$tgtpath"

# Determine whether our host is booted in Legacy BIOS or UEFI mode.
if test -e /sys/firmware/efi/systab; then
  export efimode=1
else
  export efimode=0
fi

# Set the current stage we are on.
export stage=0

# Allow the stage to be incremented and decremented as needed.
stage_inc() {
  export stage=$((stage + 1))
}
stage_dec() {
  export stage=$((stage - 1))
}

# Export variables that will be set by preloader.
export locales=() localescore=() keymaps=() keymapscore=() x11keys=() x11keyscore=() timezones=()

# Run preloader function to get locales, keymaps and timezones.
preloader

# Enter the main program loop.
while test $stage -ge 0; do
  # Run the function corresponding to the stage we are currently on.
  case $stage in
    0) stage_mainmenu ;;
    1) stage_locale ;;
    2) stage_keymap ;;
    3) stage_x11key ;;
    4) stage_timezone ;;
    5) stage_rootpw ;;
    6) stage_usersetup ;;
    7) stage_userpw ;;
    8) stage_hostname ;;
    9) stage_diskpar ;;
    10) stage_mount ;;
    11) stage_swapsetup ;;
    12) stage_installation ;;
    13) stage_postinstall ;;
    14) stage_systemconfig ;;
    15) stage_initramfs ;;
    16) stage_bootloader ;;
    17) stage_finish ;;
  esac
done

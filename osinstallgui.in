#!/usr/bin/env bash

# osinstallgui version @@VERSION@@ - Copyright (C) 2025 Daniel Massey.
# Extremely fast and minimal GUI installer for GNU/Linux operating systems.

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# The configuration file is set correctly after running 'make'.
# shellcheck disable=SC1091

# Word splitting is often done intentionally, and/or the command handles it.
# shellcheck disable=SC2086

# We manually check configuration values and set them (or die) if unset.
# shellcheck disable=SC2153

# We intentionally ignore return values from declarations in most cases.
# shellcheck disable=SC2155

# What is our name, what is our version?
export inv="$(basename "$0")"
export ver="@@VERSION@@"

# Function to write a message to the log file.
write_log() {
  echo "=== $* ===" >>"$log"
}

# Function to display an error message and exit with error.
die() {
  echo "ERROR: $*" >&2
  write_log "ERROR: $*"
  exit 1
}

# Function to display warning message.
warn() {
  echo "WARNING: $*" >&2
  write_log "WARNING: $*"
}

# Check dependency - exit if they are not found.
check_dep() {
  # $1 is the program, $2 is the package it comes from (if different).
  if ! which "$1" &>/dev/null; then
    if test ! -z "$2"; then
      die "$inv requires $1 ($2) in order to run, but it was not found."
    else
      die "$inv requires $1 in order to run, but it was not found."
    fi
  fi
}

# Functions for displaying each screen type using yad.
yad_menu() {
  local title="$1 ⎯ $inv"
  local menu="$2"
  local col1="$3"
  local col2="$4"
  shift 4
  local response="$(yad --list --title="$title" --text="$menu" --column="$col1" --column="$col2" "$@" --width=600 --height=300)"
  echo "$response"
}
yad_message() {
  yad --title="$1 ⎯ $inv" --text="$2" --width=600 --height=200 --button="OK":0
}
yad_prompt() {
  yad --title="$1 ⎯ $inv" --text="$2" --width=600 --height=200 --button="Yes":0 --button="No":1
  return $?
}
yad_input() {
  local title="$1 ⎯ $inv"
  local text="$2"
  local placeholder="$3"
  # This is the only exception to disabling SC2155, but we deal with it.
  local response
  response="$(yad --entry --title="$title" --text="$text" --entry-text="$placeholder" --width=600 --height=100 --button="OK":0)"
  local status=$?
  echo "$response"
  return $status
}
yad_password() {
  local title="$1 ⎯ $inv"
  local text="$2"
  # This is the only exception to disabling SC2155, but we deal with it.
  local response
  response="$(yad --entry --title="$title" --text="$text" --hide-text --width=600 --height=100 --button="OK":0)"
  local status=$?
  echo "$response"
  return $status
}

# Helper functions.
helper_sortentries() {
  # This function will sort an array of yad menu entries by description.
  # Do nothing if no argument was passed.
  test ! -z "$1" || return
  # Get the array.
  local itemsunsorted=()
  for item in "$@"; do
    itemsunsorted+=("$item")
  done
  # Set up the files for writing and reading back.
  # TODO: See if this whole process could be done without using files on disk.
  local sortfilepre1="$(mktemp "$workdir"/.sortpre1XXXXXX)"
  local sortfilepre2="$(mktemp "$workdir"/.sortpre2XXXXXX)"
  local sortfilepost1="$(mktemp "$workdir"/.sortpost1XXXXXX)"
  local sortfilepost2="$(mktemp "$workdir"/.sortpost2XXXXXX)"
  # Write every 1st entry to a file, and every 2nd entry to a file.
  # Do this by iterating through using the array index, not the item itself.
  for item in "${!itemsunsorted[@]}"; do
    if test $((item % 2)) -eq 0; then
      # 1st entry.
      echo "${itemsunsorted[item]}" >>"$sortfilepre1"
    else
      # 2nd entry.
      echo "${itemsunsorted[item]}" >>"$sortfilepre2"
    fi
  done
  # Sort timezones, if needed. Otherwise, sort normally by alphabetical order.
  if test "$SORTTZ" = "1"; then
    # We want to sort by UTC offset.
    # Where -12 is the first, and +12 is the last.
    # To do this, get the negative values and sort in reverse.
    # Then get the positive values and sort normally.
    paste "$sortfilepre1" "$sortfilepre2" | grep UTC- | sort -rk2 | cut -f1 >"$sortfilepost1"
    paste "$sortfilepre1" "$sortfilepre2" | grep UTC- | sort -rk2 | cut -f2 >"$sortfilepost2"
    paste "$sortfilepre1" "$sortfilepre2" | grep UTC+ | sort -k2 | cut -f1 >>"$sortfilepost1"
    paste "$sortfilepre1" "$sortfilepre2" | grep UTC+ | sort -k2 | cut -f2 >>"$sortfilepost2"
  else
    paste "$sortfilepre1" "$sortfilepre2" | sort -k2 | cut -f1 >"$sortfilepost1"
    paste "$sortfilepre1" "$sortfilepre2" | sort -k2 | cut -f2 >"$sortfilepost2"
  fi
  # Sort by the 2nd column (description), but keep consistent for 1st too.
  # Open file descriptors for both files, so we can access them while looping.
  # Use high numbers, in case lower ones are already in use for some reason.
  exec 99<"$sortfilepost1"
  exec 100<"$sortfilepost2"
  # Loop through and print each alternating line to stdout.
  while true; do
    # Break out of the loop when either read no longer succeeds (end of file).
    if read -r line1 <&99; then
      echo "$line1"
    else
      break
    fi
    if read -r line2 <&100; then
      echo "$line2"
    else
      break
    fi
  done
  # Close the file descriptors.
  exec 99<&-
  exec 100<&-
  # Now we are done, remove the temporary files.
  rm -f "$sortfilepre1" "$sortfilepre2" "$sortfilepost1" "$sortfilepost2"
}
helper_format() {
  write_log "Trying to format $1 as $2."
  case "$2" in
    ext4) mkfs.ext4 -vFL "$3" "$1" &>>"$log" ;;
    btrfs) mkfs.btrfs -vfL "$3" "$1"&>>"$log" ;;
    swap) mkswap "$1" &>>"$log" ;;
    vfat) mkfs.fat -F32 -vn "$3" "$1" &>>"$log" ;;
  esac
  local status=$?
  if test $status -eq 0; then
    write_log "Format of $1 as $2 was successful."
  else
    write_log "Format of $1 as $2 was unsuccessful."
  fi
  return $status
}
helper_mount() {
  write_log "Trying to mount $1 at $2."
  mkdir -pv "$2" &>>"$log"
  mount -v "$1" "$2" &>>"$log"
  local status=$?
  if test $status -eq 0; then
    write_log "$1 was successfully mounted at $2."
  else
    write_log "$1 was unable to be mounted at $2."
  fi
  return $status
}
helper_umount() {
  write_log "Trying to unmount $1."
  umount -Rv "$1" &>>"$log"
  local status=$?
  if test $status -eq 0; then
    write_log "$1 was successfully unmounted."
  else
    write_log "$1 was unable to be unmounted."
  fi
  return $status
}
helper_try_umount() {
  # Check if the filesystem is mounted and try to unmount if so.
  # Return with 0 for successful unmount or 1 for failure.
  # Mostly useful in partition setup stage.
  write_log "Checking mount status of $1."
  if ! mount | grep -q "$1"; then
    write_log "$1 is not mounted, we don't need to do anything."
    return 0
  fi
  sync; umount -v "$1" &>>"$log"
  sync; swapoff -v "$1" &>>"$log"
  if mount | grep -q "$1"; then
    write_log "Failed to unmount $1."
    return 1
  fi
  return 0
}
helper_chroot_advanced() {
  # Chroot with aspirations - setting up virtual filesystems too.
  # Partially adapted from the 'mass-chroot' utility from MassOS.
  test ! -z "$1" || return
  local chrootdir="$1"
  shift
  write_log "Trying to enter an advanced chroot in $chrootdir."
  # Mount virtual filesystems.
  sync
  mount -v --bind /dev "$chrootdir"/dev &>>"$log" || return
  mount -v --bind /dev/pts "$chrootdir"/dev/pts &>>"$log" || return
  mount -vt tmpfs devshm "$chrootdir"/dev/shm &>>"$log" || return
  mount -vt proc proc "$chrootdir"/proc &>>"$log" || return
  mount -vt sysfs sysfs "$chrootdir"/sys &>>"$log" || return
  mount -vt tmpfs tmpfs "$chrootdir"/run &>>"$log" || return
  mkdir -vp "$chrootdir"/run/lock &>>"$log"
  if test $efimode -eq 1; then
    # Need to also mount efivarfs filesystem for UEFI boot mode.
    mount -vt efivarfs efivarfs "$chrootdir"/sys/firmware/efi/efivars &>>"$log" || return
  fi
  sync
  # Enter the chroot.
  chroot "$chrootdir" "$@" &>>"$log"
  local chrootstatus=$?
  # Unmount virtual filesystems.
  sync
  if test $efimode -eq 1; then
    umount -Rv "$chrootdir"/sys/firmware/efi/efivars &>>"$log" || return
  fi
  umount -Rv "$chrootdir"/dev/pts &>>"$log" || return
  umount -Rv "$chrootdir"/dev/shm &>>"$log" || return
  umount -Rv "$chrootdir"/dev &>>"$log" || return
  umount -Rv "$chrootdir"/proc &>>"$log" || return
  umount -Rv "$chrootdir"/sys &>>"$log" || return
  umount -Rv "$chrootdir"/run &>>"$log" || return
  sync
  # Report the result and return.
  if test $chrootstatus -eq 0; then
    write_log "Advanced chroot exited after successful exit code."
  else
    write_log "Advanced chroot exited after unsuccessful exit code $chrootstatus."
  fi
  return $chrootstatus
}

# Preloader function - finds locales/keymaps now to prevent slowdown later.
preloader() {
  # A progress bar is needed here, since preloading can take around 15 seconds.
  # Unfortunately, the previous pipe method would cause variables to be lost.
  # This new method involves using coproc, to avoid any piping or subshells.
  # TODO: Make this the default elsewhere too.
  coproc preloaderprogress { yad --progress --title="Loading... ⎯ $inv" --text="The installer is loading, please be patient." --percentage=0 --auto-close --auto-kill --no-buttons --no-escape --width=600 --height=100; }
  # Set up the list of locales, as well as the list of the most common ones.
  write_log "Preloading locales."
  # Arrays to store the stuff into (u is for unsorted, will be sorted later).
  local ulocales=() ulocalescore=()
  # Acceptable core locales - searched locales will be matched against this.
  local localescorelist="de_DE.UTF-8 el_GR.UTF-8 en_GB.UTF-8 en_US.UTF-8 es_ES.UTF-8 es_MX.UTF-8 fr_FR.UTF-8 it_IT.UTF-8 pl_PL.UTF-8 pt_BR.UTF-8 pt_PT.UTF-8 ro_RO.UTF-8 ru_RU.UTF-8 sv_SE.UTF-8"
  # Get a list of locales from the locales file.
  while IFS= read -r line; do
    # Filter the line and then uncomment it.
    # We are filtering for UTF-8 and no comments with space between # and text.
    # We also filter out C.UTF-8, as it's in the locales file as of Glibc 2.41.
    local linefiltered="$(echo "$line" | grep UTF-8 | cut -d' ' -f1 | sed -e '/^#\s.*$/d' -e 's/#//' | sed '/^C.UTF-8/d')"
    # Only append to the list of locales if this line exists.
    if test ! -z "$linefiltered"; then
      # Cross-reference the locale descriptions data file.
      local localedesc="$(grep -sm1 "^$linefiltered:" "@@CONFPATH@@"/data/locales.desc | cut -d' ' -f2-)"
      if test -z "$localedesc"; then
        # Either locales.desc file was missing or no match was found.
        localedesc="UNKNOWN"
      fi
      # Add both the filtered locale name and its description to the list.
      ulocales+=("$linefiltered" "$localedesc")
      # If it should be in the core list, add it to that.
      for corelocale in $localescorelist; do
        if test "$corelocale" = "$linefiltered"; then
          ulocalescore+=("$linefiltered" "$localedesc")
        fi
      done
    fi
  done < "$OSINSTALLGUI_LOCALES_FILE"
  write_log "Successfully preloaded locales."
  echo "25" >&"${preloaderprogress[1]}"
  # Get a list of all supported keymaps.
  write_log "Preloading console keymaps."
  local keymapsavailable=()
  # Use the systemd localectl method if possible, otherwise search manually.
  if test "$OSINSTALLGUI_KEYMAPS_SYSTEMD" = "1" && which localectl &>/dev/null; then
    readarray -t keymapsavailable < <(localectl list-keymaps | sort -u)
  else
    readarray -t keymapsavailable < <(find "$OSINSTALLGUI_KEYMAPS_LOCATION" -type f -name \*.map.gz -exec basename {} \; | sort -u | sed 's/.map.gz//')
  fi
  # Arrays to store the stuff into (u is for unsorted, will be sorted later).
  local ukeymaps=() ukeymapscore=()
  # Define the core keymaps - the most common ones, similar to as above.
  local keymapscommon="de el es fr it pl pt ro ru sv uk us"
  # Get descriptions for each keymap.
  for keymap in "${keymapsavailable[@]}"; do
    # Cross-reference the keymap descriptions data file.
    local keymapdesc="$(grep -sm1 "^$keymap:" "@@CONFPATH@@"/data/keymaps.desc | cut -d' ' -f2-)"
    if test -z "$keymapdesc"; then
      # Either the keymaps.desc file was missing or no match was found.
      keymapdesc="UNKNOWN"
    fi
    # Add both the keymap name and its description to the list.
    ukeymaps+=("$keymap" "$keymapdesc")
    # If it should be in the core list, add it to that.
    for corekeymap in $keymapscommon; do
      if test "$corekeymap" = "$keymap"; then
        ukeymapscore+=("$keymap" "$keymapdesc")
      fi
    done
  done
  write_log "Successfully preloaded console keymaps."
  echo "50" >&"${preloaderprogress[1]}"
  # Get a list of all supported X11 keymaps (layouts, variants, descriptions).
  write_log "Preloading X11 keymaps."
  local x11layouts=() x11variants=() x11descriptions=()
  # Arrays to store the stuff into (u is for unsorted, will be sorted later).
  local ux11keys=() ux11keyscore=()
  # Set up the core values.
  local x11keyscorelist="de es fr gb gr it pl pt ro ru se us"
  # Need to write to temporary files because reading from pipe fails.
  xkbcli list | yq -o shell '.layouts[]' | grep '^layout=' | sed 's/^layout=//' > "$workdir"/.x11l
  xkbcli list | yq -o shell '.layouts[]' | grep '^variant=' | sed 's/^variant=//' | sed "s/'//g" > "$workdir"/.x11v
  xkbcli list | yq -o shell '.layouts[]' | grep '^description=' | sed 's/^description=//' | sed "s/'//g" > "$workdir"/.x11d
  # Read back the temporary files into the arrays.
  while IFS= read -r line; do
    x11layouts+=("$line")
  done < "$workdir"/.x11l
  while IFS= read -r line; do
    x11variants+=("$line")
  done < "$workdir"/.x11v
  while IFS= read -r line; do
    x11descriptions+=("$line")
  done < "$workdir"/.x11d
  # Remove temporary files now they are no longer needed.
  rm -f "$workdir"/.x11{l,v,d}
  # Remove last value from each array due to it being the 'custom' entry.
  unset "x11layouts[-1]" "x11variants[-1]" "x11descriptions[-1]"
  # Now prepare in a yad-friendly format ("layout_variant" "description").
  # Underscore is useful for displaying to user, and we can manually handle it.
  # Loop through in index mode because we also need to access other arrays.
  for x11index in "${!x11layouts[@]}"; do
    # If variant is empty, only add the layout. Otherwise add both.
    if test -z "${x11variants[x11index]}"; then
      ux11keys+=("${x11layouts[x11index]}" "${x11descriptions[x11index]}")
      # If it should be in the core list, also add it to that.
      # Note that only non-variant ones are in the core list.
      for corex11map in $x11keyscorelist; do
        if test "$corex11map" = "${x11layouts[x11index]}"; then
          ux11keyscore+=("${x11layouts[x11index]}" "${x11descriptions[x11index]}")
        fi
      done
    else
      ux11keys+=("${x11layouts[x11index]}_${x11variants[x11index]}" "${x11descriptions[x11index]}")
    fi
  done
  write_log "Successfully preloaded X11 keymaps."
  echo "75" >&"${preloaderprogress[1]}"
  # Sort each set of entries by description.
  # Store them into the normal/global (non-u) variable names.
  write_log "Sorting all sets of entries by their descriptions."
  readarray -t locales < <(helper_sortentries "${ulocales[@]}")
  readarray -t localescore < <(helper_sortentries "${ulocalescore[@]}")
  readarray -t keymaps < <(helper_sortentries "${ukeymaps[@]}")
  readarray -t keymapscore < <(helper_sortentries "${ukeymapscore[@]}")
  readarray -t x11keys < <(helper_sortentries "${ux11keys[@]}")
  readarray -t x11keyscore < <(helper_sortentries "${ux11keyscore[@]}")
  write_log "Successfully sorted all sets of entries by their descriptions."
  echo "100" >&"${preloaderprogress[1]}"
  # Export needed global variables from this preloader function.
  export locales localescore keymaps keymapscore x11keys x11keyscore
}

# Stage functions.
stage_mainmenu() {
  # Let the user choose what they want to do on the main menu.
  local choice="$(yad_menu "Main Menu" "Welcome to $osname! What would you like to do?" "Option" "Description" \
  "Install" "Begin the installation of $osname." \
  "About" "See information about this installation program." \
  "Restart" "Restart the system." \
  "Shutdown" "Shut down the system." \
  "Exit" "Exit this installation program.")"
  case "${choice%%|*}" in
    "Install") stage_inc ;;
    "About") yad_message "About" "This is osinstallgui version $ver, running on $osname, accessing data from @@CONFPATH@@, and working out of $workdir.\n\nosinstallgui is an extremely fast and minimal GUI installer for GNU/Linux operating systems.\n\nosinstallgui was created by Daniel Massey and is licensed under the GNU GPLv3+. Visit go.dmassey.net/oig for more info." ;;
    "Restart") shutdown -r now ;;
    "Shutdown") shutdown -h now ;;
    "Exit"|"") exit 0 ;;
  esac
}
stage_initinstall() {
  # This is a simple intermediary stage to verify there are some disks.
  # This ensures the user is warned about it BEFORE they proceed with setup.
  if test "$(find /sys/block -mindepth 1 -maxdepth 1 -type l ! -name dm-\* ! -name fd\* ! -name loop\* ! -name sr\* | wc -l)" = "0"; then
    yad_message "Error" "The installation cannot start because no physical disks were found on your system. If your internal drive is failing to be detected, please visit go.dmassey.net/of1 for possible troubleshooting tips."
    stage_dec
    return
  fi
  # Proceed immediately to the next stage.
  stage_inc
}
stage_locale() {
  # Ask the user to select a core locale, or "Other" for all locales.
  local choice="$(yad_menu "Language Setup" "Please select the locale which corresponds to your preferred language. Choose 'Other' to see all locales." "Locale" "Description" "${localescore[@]}" "Other" "Show all available locales")"
  choice="${choice%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice"; then
    stage_dec; stage_dec
    return
  fi
  # If the user selected "Other", then go to the submenu.
  if test "$choice" = "Other"; then
    # Ask the user to select from all possible locales.
    choice="$(yad_menu "Language Setup" "Please select the locale which corresponds to your preferred language. This is the list of all available locales." "Locale" "Description" "${locales[@]}")"
    choice="${choice%%|*}"
    # Start locale setup again if the user backed out of this submenu.
    test ! -z "$choice" || return
  fi
  # Save the choice to the global configuration and move to the next stage.
  export tgtlocale="$choice"
  stage_inc
}
stage_keymap() {
  # Ask the user to select a core keymap, or "Other" for all keymaps.
  local choice="$(yad_menu "Keyboard Setup" "Please select the console keymap which corresponds to your preferred keyboard layout. Choose 'Other' to see all keymaps." "Keymap" "Description" "${keymapscore[@]}" "Other" "Show all available keymaps and variants")"
  choice="${choice%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice"; then
    stage_dec
    return
  fi
  # If the user selected "Other", then go to the submenu.
  if test "$choice" = "Other"; then
    # Ask the user to select from all possible keymaps.
    choice="$(yad_menu "Keyboard Setup" "Please select the console keymap which corresponds to your preferred keyboard layout. This is the list of all available keymaps and variants." "Keymap" "Description" "${keymaps[@]}")"
    choice="${choice%%|*}"
    # Start keymap setup again if the user backed out of this submenu.
    test ! -z "$choice" || return
  fi
  # Save the choice to the global configuration and move to the next stage.
  export tgtkeymap="$choice"
  stage_inc
}
stage_x11key() {
  # Ask the user to select an X11 keymap.
  local choice="$(yad_menu "Keyboard Setup" "Please select the X11 keymap which best corresponds to your preferred layout. Choose 'Other' to see all keymaps." "Keymap" "Description" "${x11keyscore[@]}" "Other" "Show all available keymaps and variants")"
  choice="${choice%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice"; then
    stage_dec
    return
  fi
  # If the user selected "Other", then go to the submenu.
  if test "$choice" = "Other"; then
    # Ask the user to select from all possible keymaps.
    choice="$(yad_menu "Keyboard Setup" "Please select the X11 keymap which corresponds to your preferred keyboard layout. This is the list of all available keymaps and variants." "Keymap" "Description" "${x11keys[@]}")"
    choice="${choice%%|*}"
    # Start keymap setup again if the user backed out of this submenu.
    test ! -z "$choice" || return
  fi
  # Save the choice to the global configuration and move to the next stage.
  export tgtx11key="$choice"
  stage_inc
}
stage_timezone() {
  # Get a list of regions, filtering out non-Continents and non-Oceans.
  local tzregions=()
  for tzregion in $(find /usr/share/zoneinfo -mindepth 1 -maxdepth 1 -type d ! -name right ! -name posix ! -name Etc ! -name Brazil ! -name Canada ! -name Chile ! -name Mexico ! -name US -exec basename {} \; | sort -u); do
    # Specify whether regions are continents or oceans, to avoid confusion.
    local tzregdesc
    case "$tzregion" in
      "Arctic"|"Atlantic"|"Indian"|"Pacific") tzregdesc="$tzregion Ocean Territories" ;;
      "America") tzregdesc="North, Central and South America" ;;
      *) tzregdesc="" ;;
    esac
    tzregions+=("$tzregion" "$tzregdesc")
  done
  # Let the user decide which region are in, before finding the cities.
  local choice_tzregion="$(yad_menu "Timezone Setup" "Please select the region which best corresponds to your geographical location." "Region" "Description" "${tzregions[@]}")"
  choice_tzregion="${choice_tzregion%%|*}"
  # Go back to the previous stage if the user backed out.
  if test -z "$choice_tzregion"; then
    stage_dec
    return
  fi
  # Get a list of cities corresponding to the selected region.
  local utzcities=()
  for tzcity in $(find /usr/share/zoneinfo/"$choice_tzregion" -mindepth 1 -maxdepth 1 -type f -exec basename {} \; | sort -u); do
    # Display the city with its UTC offset for the description.
    utzcities+=("$tzcity" "$(TZ="$choice_tzregion/$tzcity" date +%z | sed -e 's/-/UTC-/' -e 's/+/UTC+/')")
  done
  # Sort entries by UTC offset.
  local tzcities=()
  readarray -t tzcities < <(SORTTZ=1 helper_sortentries "${utzcities[@]}")
  # Let the user decide which city they are in from their selected region.
  local choice_tzcity="$(yad_menu "Timezone Setup" "Please select the city from $choice_tzregion which best corresponds to your geographical location. Note that the UTC offsets, displayed in the right-hand column, will account for daylight saving time where applicable." "City" "UTC Offset" "${tzcities[@]}")"
  choice_tzcity="${choice_tzcity%%|*}"
  # Start again from region selection if the user backs out.
  test ! -z "$choice_tzcity" || return
  # Mark this timezone for later use.
  export tgttimezone="$choice_tzregion/$choice_tzcity"
  # Move on to the next stage.
  stage_inc
}
stage_rootpw() {
  # Only do this stage if rootpw is enabled in the osinstallgui configuration.
  if test "$OSINSTALLGUI_ROOTPW" = "1"; then
    # Ask the user for the root password. Again SC2155 applies here.
    local rootpw1
    rootpw1="$(yad_password "Root Password" "Please enter a new password for the system's root account. Leave the field empty to disable the root account (users willl still be able elevate using 'sudo').")"
    # Go back to the previous stage if the user backed out.
    if test $? -ne 0; then
      stage_dec
      return
    fi
    # Check if the root password field is empty.
    if test -z "$rootpw1"; then
      # Unsave the existing root password, in case the user went back a stage.
      export tgtrootpw=""
      # Skip ahead to the next stage immediately.
      stage_inc
      return
    fi
    # Now ask for the root password again, for verification purposes.
    local rootpw2
    rootpw2="$(yad_password "Root Password" "Please repeat the new password for the root account.")"
    test $? -eq 0 || return
    # Ensure the passwords match.
    if test "$rootpw1" != "$rootpw2"; then
      # Complain about this problem to the user.
      yad_message "Error" "The passwords you entered for the root account do not match."
      return
    fi
    # Password was set successfully. Save it for later.
    export tgtrootpw="$rootpw1"
  fi
  # Go to the next stage.
  stage_inc
}
stage_usersetup() {
  # Take note that SC2155 will apply for all input boxes in this section.
  # Ask the user for their full name. User can leave this blank if they wish.
  local fullname
  fullname="$(yad_input "User Setup" "Please enter the full name of the primary user. This field can be left blank if you'd prefer the new account to only be identifiable by its username.")"
  # Go back to the previous stage if the user backed out.
  if test $? -ne 0; then
    # Previous stage is one behind if root password is enabled, two if not.
    if test "$OSINSTALLGUI_ROOTPW" != "1"; then
      stage_dec
    fi
    stage_dec
    return
  fi
  # Filter input for only alphanumeric characters and spaces.
  fullname="$(echo "$fullname" | tr -cd '[:alnum:] [:space:]')"
  # Filter username for only the first word (i.e., forename), and lowercase.
  local usernameauto="$(echo "$fullname" | cut -d' ' -f1 | tr '[:upper:]' '[:lower:]')"
  # Display the input box using the auto-generated username as the placeholder.
  # It will of course be blank if the full name entry was skipped.
  local username
  username="$(yad_input "User Setup" "Please enter the username you wish to use for the account. It may only consist of lowercase alphanumeric characters, and must not contain spaces." "$usernameauto")"
  # Start again if the user backed out.
  test $? -eq 0 || return
  # Filter input as necessary.
  username="$(echo "$username" | tr -cd '[:alnum:]' | tr '[:upper:]' '[:lower:]')"
  # Start again (after displaying a message) if the field was left blank.
  if test -z "$username"; then
    yad_message "Error" "The username field must not be left blank."
    return
  fi
  # Now set the global values and move on to the user password stage.
  export tgtusername="$username" tgtfullname="$fullname"
  stage_inc
}
stage_userpw() {
  # Once again, SC2155 will apply for the input boxes here, so take care.
  # Go back to the previous stage if the username was not set.
  if test -z "$tgtusername"; then
    stage_dec
    return
  fi
  # Ask the user for the password.
  local userpw1
  userpw1="$(yad_password "User Setup" "Please think of a secure password for the account '$tgtusername', and enter it here.")"
  # Go back to the previous stage if the user backed out.
  if test $? -ne 0; then
    stage_dec
    return
  fi
  # Ensure the field was not left blank.
  if test -z "$userpw1"; then
    # User didn't listen.
    yad_message "Error" "The password field cannot be left blank. You must think of a secure password for the account '$tgtusername'."
    return
  fi
  # Ensure the password is strong if cracklib-check is enabled and installed.
  if test "$OSINSTALLGUI_USER_PWSCORE" = "1" && which cracklib-check &>/dev/null; then
    # Invoke cracklib-check, capturing output and filtering only the reason.
    local userpwscore="$(echo "$userpw1" | cracklib-check | sed "s/$userpw1: //")"
    # If the password check failed due to it being insecure.
    if test "$userpwscore" != "OK"; then
      # userpwscore will contain the reason it failed the check.
      yad_message "Error" "The password you entered is not strong enough. This is because $userpwscore."
      return
    fi
  fi
  # Ask for the password again, for verification purposes.
  local userpw2
  userpw2="$(yad_password "User Setup" "Please repeat the new password for the account '$tgtusername'.")"
  # Ensure the passwords match.
  if test "$userpw1" != "$userpw2"; then
    yad_message "Error" "The passwords you entered for the account '$tgtusername' do not match."
    return
  fi
  # User password setup is done, now save and move on to the next stage.
  export tgtuserpw="$userpw1"
  stage_inc
}
stage_hostname() {
  # The default hostname will be in the format 'username-SystemModel'.
  # We will use dmidecode to find the model, if possible, or fallback to 'PC'.
  # We will also strip out non-alphanumeric/non-space/non-dash characters.
  # And then we will replace all spaces with dashes.
  # This is to be compliant with the hostname requirements.
  local defaulthostname="$tgtusername-$({ dmidecode -s system-product-name 2>/dev/null || echo "PC"; } | tr -cd '[:alnum:] [:space:] -' | sed 's/ /-/g')"
  # Collect the input using the default hostname as the default/placeholder.
  local hostname
  hostname="$(yad_input "Hostname" "Please enter your desired hostname which will identify this computer to the network." "$defaulthostname")"
  # Go back if the user backed out.
  if test $? -ne 0; then
    stage_dec
    return
  fi
  # Filter out special characters from the hostname, and truncate to 255.
  hostname="$(echo "$hostname" | tr -cd '[:alnum:] [:space:] -' | sed 's/ /-/g' | cut -c1-255)"
  # Ensure the hostname is not empty.
  if test -z "$hostname"; then
    # Complain and try again.
    yad_message "Error" "The system hostname must not be left blank."
    return
  fi
  # Save our work.
  export tgthostname="$hostname"
  # Move on to the next stage.
  stage_inc
}
stage_diskpar() {
  # New method which is designed to merge disk setup and partition setup.
  # It also allows for more flexibility, i.e., for multi-disk setups.
  # First, detect the disk containing the installation media, if any.
  local findlivepar="$(findmnt -no SOURCE -T "$OSINSTALLGUI_ROOTFS" 2>/dev/null)"
  # Only deal with it if it is a partition of a physical disk.
  if test ! -z "$findlivepar" && test -b "$findlivepar"; then
    # Find the source disk.
    local findlivedisk="$(lsblk -no PKNAME "$findlivepar" 2>/dev/null)"
    # Ensure it's a physical disk, again.
    if test ! -z "/dev/$findlivedisk" && test -b "/dev/$findlivedisk"; then
      # Set up this disk to be filtered out.
      local imdisk="$findlivedisk"
    fi
  fi
  # Detect all real disks, filtering out the installation media if needed.
  local disks=()
  readarray -t disks < <(find /sys/block -mindepth 1 -maxdepth 1 -type l ! -name dm-\* ! -name fd\* ! -name loop\* ! -name sr\* -exec basename {} \; | sort | grep -vx "$imdisk")
  # Throw an error if no disks were found.
  if test ${#disks[@]} -eq 0; then
    yad_message "Error" "No physical disks were found on your system. If your internal drive is failing to be detected, please visit go.dmassey.net/of1 for troubleshooting tips."
    # Go back to the main menu, since a reboot will probably be needed.
    export stage=0
    return
  fi
  # Set up the menu.
  local choice="$(yad_menu "Disk Setup" "Please choose how you would like to set up the disk(s) for installation." "Option" "Description" \
  "1" "Erase an entire disk and install $osname." \
  "2" "Select an existing partition to install $osname to." \
  "3" "Manually create and/or modify partitions before installing." \
  "4" "More information and clarification about this question.")"
  # Decide what to do based on the user's selection.
  case "${choice%%|*}" in
    "1")
      # Get details of each disk, for displaying in the disk selection menu.
      local diskentries=()
      for disk in "${disks[@]}"; do
        # Description includes both disk size (calculated in GiB) and disk model.
        # Both identifier and description get appended as expected by yad menu.
        diskentries+=("/dev/$disk" "$(($(cat "/sys/block/$disk/size") * 512 / 1073741824))GiB ⎯ $(cat "/sys/block/$disk/device/model")")
      done
      # Now display the entries to the user, so they can choose which disk to use.
      local choice="$(yad_menu "Disk Setup" "Please select the disk to erase and use for the installation." "Disk" "Description" "${diskentries[@]}")"
      # Restart to the top menu of this function if the user backed out.
      test ! -z "$choice" || return
      # Set up the selection.
      local diskselection="${choice%%|*}"
      # Get the list of mounted partitions (if any), sorted by mount depth.
      local mountedparts="$(mount | grep "$diskselection" | cut -d' ' -f1,3 | sort -rk2 | cut -d' ' -f1)"
      # Allow us to try and unmount them if any exist.
      if test ! -z "$mountedparts"; then
        # Let the user decide if they want to try to unmount the partitions.
        if yad_prompt "Warning" "The selected disk appears to have mounted partitions. In order to use it for the installation, all partitions must first be unmounted. Do you want this program to try and unmount them for you?"; then
          # Try to unmount each partition. Sort was done because we can't use -R.
          for part in $mountedparts; do
            sync; umount "$part" &>>/dev/null
            sync; swapoff "$part" &>>/dev/null
          done
          # Check if there are still mounted partitions.
          if mount | grep -q "$diskselection"; then
            # Complain and return.
            yad_message "Error" "This program was unable to unmount all partitions on the disk. Please try to unmount them manually, or alternatively select a different disk for the installation."
            return
          fi
        else
          # User didn't even let us try, what can we do?
          return
        fi
      fi
      # Ask about fully portable mode if necessary.
      # Either the disk is removable or always offer option is enabled.
      # But we need a different prompt for each, so as to not confuse the user.
      if test "$OSINSTALLGUI_ALWAYS_OFFER_FULLPORT" = "1" && yad_prompt "Erase Disk" "Would you like to set up this disk for a fully portable installation, so it can be easily moved between and booted on different computers? Answer 'NO' unless you are installing onto a USB flash drive or portable HDD/SSD. See go.dmassey.net/of2 for more information."; then
        local fullyportable=1
      elif udevadm info -q property -n "$diskselection" | grep -qE '^ID_USB_DRIVER|^ID_BUS=usb' && yad_prompt "Erase Disk" "The installer detected the selected disk to be a removable drive (e.g., USB flash drive or portable HDD/SSD). Would you like to set up this disk for a fully portable installation, so it can be easily moved between and booted on different computers? See go.dmassey.net/of2 for more information."; then
        local fullyportable=1
      else
        local fullyportable=0
      fi
      # Ask if btrfs should be used, if supported and enabled in configuration.
      if test "$OSINSTALLGUI_ALLOW_BTRFS" = "1" && which mkfs.btrfs &>/dev/null && yad_prompt "Erase Disk" "Would you like to use btrfs for the root partition? This is recommended, unless you have a specfic reason to prefer the traditional ext4."; then
        local btrfsuse=1
      else
        local btrfsuse=0
      fi
      # Ask if the user wants to split root and boot.
      if yad_prompt "Erase Disk" "Would you like to have '/' and '/boot' on separate partitions? It is recommended (but not required) that you answer 'YES' if you intend to set up disk encryption with LUKS, and 'NO' otherwise. Visit go.dmassey.net/of3 for more clarification about this question."; then
        local splitbootuse=1
      else
        local splitbootuse=0
      fi
      # Ask if the user wants swap space.
      if yad_prompt "Erase Disk" "Swap is a reserved area on the disk which can act as an emergency RAM backup in case the system RAM becomes full. Would you like to make use of a swap file?"; then
        # Ask how much swap space the user wants.
        local choiceswapsize="$(yad_menu "Erase Disk" "Please select the size you wish the swap file to be. Be advised that higher sizes will reduce the amount of free space you have after installation." "Size" "Note" \
        "2G" "Default" \
        "4G" "" \
        "8G" "" \
        "16G" "")"
        local swapsize="${choiceswapsize%%|*}"
        # If the user backed out of the menu, use the default value.
        if test -z "$swapsize"; then
          swapsize="2G"
        fi
      fi
      # Final warning before fully erasing the disk.
      yad_prompt "Erase Disk" "WARNING! Any existing data on the disk $diskselection is now going to be PERMANENTLY DELETED. This action is IRREVERSIBLE. Are you sure you want to continue?" || return
      # Wipe filesystems, overwrite MBR (if any), and erase GPT (if any).
      write_log "Erasing the disk $diskselection."
      sync; wipefs -af "$diskselection" &>>"$log"
      sync; dd if=/dev/zero of="$diskselection" bs=1M count=10 &>>"$log"
      sync; sgdisk -Z "$diskselection" &>>"$log"
      sync; partprobe &>>"$log"
      write_log "Finished erasing the disk $diskselection."
      # Decide which partitions to make depending on boot mode.
      if test $fullyportable -eq 1; then
        # For hybrid booting, we need GPT with both BIOS boot + EFI partitions.
        if test $splitbootuse -eq 1; then
          # ... And an additional boot partition due to split boot.
          local operations='g\nn\n\n\n+1M\nt\n4\nn\n\n\n+500M\nt\n2\n1\nn\n\n\n+1G\nn\n\n\n\nw\n'
        else
          local operations='g\nn\n\n\n+1M\nt\n4\nn\n\n\n+500M\nt\n2\n1\nn\n\n\n\nw\n'
        fi
      elif test $efimode -eq 1; then
        if test $splitbootuse -eq 1; then
          # Standard UEFI with split boot.
          local operations='g\nn\n\n\n+500M\nt\n1\nn\n\n\n+1G\nn\n\n\n\nw\n'
        else
          # Standard UEFI.
          local operations='g\nn\n\n\n+500M\nt\n1\nn\n\n\n\nw\n'
        fi
      else
        if test $splitbootuse -eq 1; then
          # Standard Legacy BIOS with split boot.
          local operations='o\nn\n\n\n\n+1G\nn\n\n\n\n\nw\n'
        else
          # Standard Legacy BIOS.
          local operations='o\nn\n\n\n\n\nw\n'
        fi
      fi
      # Partition the disk.
      write_log "Partitioning the disk $diskselection using fdisk."
      echo -e "$operations" | fdisk "$diskselection" &>>"$log"
      if test $? -ne 0; then
        # OH NO! It failed, this could be bad.
        write_log "Failed to partition the disk $diskselection using fdisk."
        yad_message "Error" "Failed to partition the disk $diskselection (fdisk returned an unsuccessful exit code). A log file can be found at $log."
        return
      fi
      # Get a list of all the partitions which were just created.
      local createdparts=()
      readarray -t createdparts < <(lsblk -lnp "$diskselection" | grep part | cut -d' ' -f1)
      # Ensure the disk was partitioned correctly by counting the partitions.
      # May not be needed, but done to catch program bugs and rare edge cases.
      local countpartfail=0
      if test $splitbootuse -eq 1; then
        if test $fullyportable -eq 1 && test -z "${createdparts[3]}" || test $efimode -eq 1 && test -z "${createdparts[2]}" || test -z "${createdparts[1]}"; then
          countpartfail=1
        fi
      elif test $fullyportable -eq 1 && test -z "${createdparts[2]}" || test $efimode -eq 1 && test -z "${createdparts[1]}" || test -z "${createdparts[0]}"; then
        countpartfail=1
      fi
      # Display an error message and return if the count check failed.
      if test $countpartfail -eq 1; then
        yad_message "Error" "Failed to partition the disk $diskselection (the operation didn't create all needed partitions). A log file can be found at $log."
        return
      fi
      # Set up the global variables, now we are done with this process.
      export tgtdisk="$diskselection"
      # Root partition is always the last partition on the disk (-1 index).
      export tgtroot="${createdparts[-1]}"
      # EFI is partition 1 on normal and partition 2 on fullyportable.
      if test $efimode -eq 1; then
        if test $fullyportable -eq 1; then
          export tgtefi="${createdparts[1]}"
        else
          export tgtefi="${createdparts[0]}"
        fi
      fi
      # Boot, if needed, is partition 1 on BIOS, 2 on UEFI, 3 on fullyportable.
      if test $splitbootuse -eq 1; then
        if test $fullyportable -eq 1; then
          export tgtboot="${createdparts[2]}"
        elif test $efimode -eq 1; then
          export tgtboot="${createdparts[1]}"
        else
          export tgtboot="${createdparts[0]}"
        fi
      else
        # Set tgtboot empty in case it spilled over from a cancelled selection.
        export tgtboot=""
      fi
      # Save the filesystem used for the root partition.
      if test $btrfsuse -eq 1; then
        export tgtfs="btrfs"
      else
        export tgtfs="ext4"
      fi
      # We by default will need to format the EFI partition.
      export tgtefiformat=1
      # We need to inform the future stages that the installation is portable.
      if test $fullyportable -eq 1; then
        export tgtfullport=1
      else
        export tgtfullport=0
      fi
      # Save the swap size.
      export tgtswap="$swapsize"
      # Move on to the partition formatting stage.
      stage_inc
      ;;
    "2")
      # TODO: Rework to not restart on menu backouts or invalid selections.
      # Get a list of every partition on every disk.
      local partentries=()
      for disk in "${disks[@]}"; do
        # List partitions on this disk.
        local individualdiskparts=()
        readarray -t individualdiskparts < <(lsblk -lnp "/dev/$disk" | grep part | cut -d' ' -f1)
        # Go through each of these partitions and add them to the top entry.
        for part in "${individualdiskparts[@]}"; do
          # Get partition details.
          local partsize="$(lsblk -lnp "$part" | xargs | cut -d' ' -f4)"
          local partfs="$(blkid -o value -s TYPE "$part")"
          local partlabel="$(blkid -o value -s LABEL "$part")"
          # Unknown filesystem would be blank by default.
          if test -z "$partfs"; then
            partfs="unknown"
          fi
          # Add the entry, description is based on whether it is labelled or not.
          if test ! -z "$partlabel"; then
            partentries+=("$part" "$partsize ⎯ $partfs ⎯ $partlabel")
          else
            partentries+=("$part" "$partsize ⎯ $partfs")
          fi
        done
      done
      # Throw an error and go back if there are no partitions on any disk.
      if test ${#partentries[@]} -eq 0; then
        yad_message "Error" "No partitions were found on any disk. Please choose the 'Erase Disk' option instead, or alteratively use the 'Manual Partitioning' option to create the required partitions on the disk(s)."
        return
      fi
      # Ask which root partition to use.
      local choicerootpar="$(yad_menu "Partition Setup" "Please select the partition you wish to use for the root filesystem. It will be formatted, and any existing data on it will be deleted. The suggested minimum size is 16GiB." "Partition" "Description" "${partentries[@]}")"
      # Go back if the user backed out.
      test ! -z "$choicerootpar" || return
      # Filter yad return value to get the selection.
      local rootparselection="${choicerootpar%%|*}"
      # Check if the partition is mounted and try to unmount if so.
      if ! helper_try_umount "$rootparselection"; then
        yad_message "Error" "The selected partition $rootparselection is mounted and this program failed to unmount it automatically. Please try to unmount it manually, or alternatively select a different partition."
        return
      fi
      # Ask whether they want btrfs or ext4, if allowed.
      local btrfsuse=0
      if test "$OSINSTALLGUI_ALLOW_BTRFS" = "1" && which mkfs.btrfs &>/dev/null && yad_prompt "Partition Setup" "Would you like to use btrfs for the root partition? This is recommended, unless you have a specfic reason to prefer the traditional ext4."; then
        btrfsuse=1
      fi
      # Prompt for selection of an EFI partition if we are in UEFI mode.
      if test $efimode -eq 1; then
        # Show an information message.
        yad_message "Partition Setup" "Your system is booted in UEFI mode. A separate FAT32 (vfat) partition must therefore exist, to store the bootloader files. If it is used by another OS, it can be shared with MassOS without needing to be re-formatted. The suggested size is 100MiB-500MiB. Visit go.dmassey.net/of4 for more information."
        # Ask which EFI partition to use.
        local choiceefipar="$(yad_menu "Partition Setup" "Please select the partition you wish to use for EFI system. It must DIFFER from the selection for the root partition. The suggested size is 100MiB-500MiB." "Partition" "Description" "${partentries[@]}")"
        # Go back if the user backed out.
        test ! -z "$choiceefipar" || return
        # Filter yad return value to get the selection.
        local efiparselection="${choiceefipar%%|*}"
        # The root partition and EFI partition cannot be the same.
        if test "$efiparselection" = "$rootparselection"; then
          # Did the user not even listen to what they were told?
          yad_message "Error" "The selected EFI system partition $efiparselection must NOT be the same as the root partition $rootparselection. Please select a different partition."
          return
        fi
        # Check if the partition is mounted and try to unmount if so.
        if ! helper_try_umount "$efiparselection"; then
          yad_message "Error" "The selected partition $efiparselection is mounted and this program failed to unmount it automatically. Please try to unmount it manually, or alternatively select a different partition."
          return
        fi
        # If the selected partition is not vfat, then we need to format it.
        local efiformat=0
        if test "$(blkid -o value -s TYPE "$efiparselection")" != "vfat"; then
          if yad_prompt "Partition Setup" "The selected EFI system partition $efiparselection is not formatted as vfat (FAT32). It will therefore be formatted by this program, and any existing data on it will be deleted. Is this OK?"; then
            # Mark that we need to format this.
            efiformat=1
          else
            # We cannot use it if the user doesn't want to format it.
            return
          fi
        fi
      fi
      # Ask if the user wants to use a split boot partition.
      local splitbootuse=0
      if yad_prompt "Partition Setup" "Would you like to select a separate partition to use for '/boot'? This can make it easier to use LUKS encryption, but requires a spare partition on the disk, which will be formatted and cannot be the same as your selections for the root or EFI partition. Answer 'NO' if you are unsure. Visit go.dmassey.net/of3 for more clarification about this question."; then
        # Ask which boot partition to use.
        local choicebootpar="$(yad_menu "Partition Setup" "Please select the partition you wish to use for boot. It must DIFFER from the selections for the root and EFI partition (if applicable). The suggested size is 1GiB." "Partition" "Description" "${partentries[@]}")"
        # Go back if the user backed out.
        test ! -z "$choicebootpar" || return
        # Filter yad return value to get the selection.
        local bootparselection="${choicebootpar%%|*}"
        # The partition must not be the same as root or EFI.
        if test "$bootparselection" = "$rootparselection" || test "$bootparselection" = "$efiparselection"; then
          # Did the user STILL not listen to what they were told?
          # TODO: Handle this more gracefully.
          if test $efimode -eq 1; then
            yad_message "Error" "The selected boot partition $bootparselection must NOT be the same as the root partition $rootparselection or the EFI partition $efiparselection."
          else
            yad_message "Error" "The selected boot partition $bootparselection must NOT be the same as the root partition $rootparselection."
          fi
          return
        fi
        # Check if the partition is mounted and try to unmount if so.
        if ! helper_try_umount "$bootparselection"; then
          yad_message "Error" "The selected partition $bootparselection is mounted and this program failed to unmount it automatically. Please try to unmount it manually, or alternatively select a different partition."
          return
        fi
        # Mark that split boot is in use.
        splitbootuse=1
      fi
      # Ask if the user wants swap space, same as in erase disk option.
      local swapsize
      if yad_prompt "Partition Setup" "Swap is a reserved area on the disk which can act as an emergency RAM backup in case the system RAM becomes full. Would you like to make use of a swap file?"; then
        # Ask how much swap space the user wants.
        local choiceswapsize="$(yad_menu "Erase Disk" "Please select the size you wish the swap file to be. Be advised that higher sizes will reduce the amount of free space you have after installation." "Size" "Note" \
        "2G" "Default" \
        "4G" "" \
        "8G" "" \
        "16G" "")"
        swapsize="${choiceswapsize%%|*}"
        # If the user backed out of the menu, use the default value.
        if test -z "$swapsize"; then
          swapsize="2G"
        fi
      fi
      # Final warning before we format.
      local formatinfo=""
      # Whether or not EFI partition needs formatting.
      if test $efimode -eq 1 && test $efiformat -eq 1; then
        formatinfo+="\n- $efiparselection ($(lsblk -lnp "$efiparselection" | xargs | cut -d' ' -f4)) as vfat [/boot/efi]"
      fi
      # Whether or not the root partition will be formatted as btrfs or ext4.
      if test $btrfsuse -eq 1; then
        formatinfo+="\n- $rootparselection ($(lsblk -lnp "$rootparselection" | xargs | cut -d' ' -f4)) as btrfs [/]"
      else
        formatinfo+="\n- $rootparselection ($(lsblk -lnp "$rootparselection" | xargs | cut -d' ' -f4)) as ext4 [/]"
      fi
      # Whether or not there is a separate boot partition.
      if test $splitbootuse -eq 1; then
        if test $btrfsuse -eq 1; then
          formatinfo+="\n- $bootparselection ($(lsblk -lnp "$bootparselection" | xargs | cut -d' ' -f4)) as btrfs [/boot]"
        else
          formatinfo+="\n- $bootparselection ($(lsblk -lnp "$bootparselection" | xargs | cut -d' ' -f4)) as ext4 [/boot]"
        fi
      fi
      # Whether or not there is a swapfile.
      if test ! -z "$swapsize"; then
        formatinfo+="\n- $swapsize swap file [/swapfile]"
      fi
      # Display the message, go back if the user backs out.
      yad_prompt "Partition Setup" "The following partition(s) are now going to be formatted, and any existing data will be PERMANENTLY DELETED. This action is IRREVERSIBLE. Are you sure you want to proceed?\n\n$formatinfo" || return
      # Save the partition selections for the rest of the installation.
      export tgtroot="$rootparselection" tgtefi="$efiparselection"
      # Save whether or not we are formatting as btrfs or ext4.
      if test $btrfsuse -eq 1; then
        export tgtfs="btrfs"
      else
        export tgtfs="ext4"
      fi
      # Save the swap size.
      export tgtswap="$swapsize"
      # Save whether or not we are going to format the EFI system partition.
      export tgtefiformat=$efiformat
      # Save the boot partition selection if applicable.
      if test $splitbootuse -eq 1; then
        export tgtboot="$bootparselection"
      else
        # Unset the selection in case it spilled over from a previous back-out.
        export tgtboot=""
      fi
      # Installing GRUB for Legacy BIOS requires the raw disk to be known.
      # However, we only know about partitions and they could be multi-disk.
      # So to determine the raw disk, we will use disk of boot partition.
      # If split-boot is not in use then we will use disk of root partition.
      # As this is only needed on Legacy BIOS, ignore the EFI system partition.
      if test $splitbootuse -eq 1; then
        export tgtdisk="/dev/$(lsblk -no PKNAME "$bootparselection")"
      else
        export tgtdisk="/dev/$(lsblk -no PKNAME "$rootparselection")"
      fi
      # The manual installation method does not support fully portable mode.
      export tgtfullport=0
      # Proceed to the next stage.
      stage_inc
      ;;
    "3")
      # Launch GParted as an external program, if it is available.
      if which gparted &>/dev/null; then
        yad_message "Manual Partitioning" "The GParted graphical partitioning program will be launched. Once you have finished partitioning with this program, close the program, then the installation process will continue."
        write_log "Launching GParted as an external program."
        gparted &>>"$log"
        write_log "Execution of GParted as an external program finished."
        return
      else
        yad_message "Error" "Unable to start manual partitioning because GParted does not appear to be installed on the system. You may still be able to use alternative software outside of this installer, to be able to manually partition the disk."
        return
      fi
      ;;
    "4")
      # Display a help message.
      yad_message "Disk Setup" "$osname needs to be installed onto a physical storage disk on your system. This installer provides several options to choose from for disk setup, depending on your needs.\n\nChoose 1 if $osname is the only (or first) OS to be installed on this machine. This will erase the entire selected disk and install $osname to it.\n\nChoose 2 if you are dual-booting or have custom partitioning you don't want to overwrite. This option lets you select an existing partition on a disk, to install $osname to. On UEFI systems, it also allows selecting an EFI partition on a different disk, for multi-disk setups.\n\nChoose 3 to manually create/modify partitions before proceeding."
      ;;
    "")
      # Go back to the previous stage.
      stage_dec
      ;;
  esac
}
stage_luks() {
  # Set up the installation for LUKS encryption.
  if test "$OSINSTALLGUI_ALLOW_LUKS" = "1" && yad_prompt "Encryption Setup" "Would you like to enable disk encryption using LUKS? This will require creating a passphrase which will then need to be typed on every boot. See go.dmassey.net/of5 for more info. If unsure, answer 'NO'."; then
    # Ask for the LUKS passphrase.
    local luksphrase1
    luksphrase1="$(yad_password "Encryption Setup" "Please enter the new encryption passphrase you wish to use. Be aware that if you ever forget this, your data will be as good as gone.")"
    # Start again if the user backed out.
    test $? -eq 0 || return
    # Do not allow the phrase to be empty.
    if test -z "$luksphrase1"; then
      yad_message "Error" "The encryption passphrase must not be left blank."
      return
    fi
    # Ask for the phrase again, for confirmation.
    local luksphrase2
    luksphrase2="$(yad_password "Encryption Setup" "Please re-type the new encryption passphrase.")"
    # Start again if the user backed out.
    test $? -eq 0 || return
    # Ensure the phrases match.
    if test "$luksphrase2" != "$luksphrase1"; then
      yad_message "Error" "The encryption passphrases you entered do not match."
      return
    fi
    # Mark encryption as enabled, and set the global LUKS passphrase.
    export tgtluks=1
    export tgtlukspw="$luksphrase1"
  fi
  # Move on to the next stage.
  stage_inc
}
stage_format() {
  # Go back a stage if the root partition is unset.
  if test -z "$tgtroot"; then
    stage_dec
    return
  fi
  # Sync again first, just in case.
  sync
  # Use coproc, so we can have a progress bar, as format of LUKS takes a while.
  coproc formatprogress { yad --progress --title="Loading... ⎯ $inv" --text="The partitions are being formatted, please be patient." --percentage=0 --auto-close --auto-kill --no-buttons --no-escape --width=600 --height=100; }
  # Deal with LUKS encryption support using cryptsetup.
  if test $tgtluks -eq 1; then
    # Format to LUKS and open as a mapper device (/dev/mapper/cryptroot).
    # Note that argon2 is unsupported by GRUB - make sure pbkdf2 is used.
    # Also use 1M, as it's the best tradeoff between boot speed and security.
    write_log "Formatting $tgtroot for LUKS encryption."
    echo -n "$tgtlukspw" | cryptsetup luksFormat "$tgtroot" --type luks2 --pbkdf pbkdf2 --pbkdf-force-iterations 1000000 - &>>"$log"
    if test $? -ne 0; then
      write_log "Failed to format $tgtroot for LUKS encryption."
      yad_message "Error" "Failed to format the root filesystem $tgtroot for LUKS encryption. A log file can be found at $log."
      stage_dec; stage_dec
      return
    fi
    echo -n "$tgtlukspw" | cryptsetup open "$tgtroot" cryptroot - &>>"$log"
    if test $? -ne 0; then
      yad_message "Error" "Failed to open the newly created LUKS-encrypted filesystem. A log file can be found at $log."
      # Forcibly close the cryptsetup device just in case something weird happened.
      cryptsetup close cryptroot &>>/dev/null
      stage_dec; stage_dec
      return
    fi
    # Set tgtroot to /dev/mapper/cryptroot, and then save raw root partition.
    export tgtluksraw="$tgtroot"
    export tgtroot="/dev/mapper/cryptroot"
  fi
  echo "50" >&"${formatprogress[1]}"
  # Determine the label for the root filesystem, based on OS name.
  local rootlabel="$(echo "$osname" | cut -d' ' -f1)"
  # Try to format the partitions. Step back a stage if any format fails.
  # Note that BIOS boot (fullyportable) doesn't need to be formatted at all.
  if test "$tgtfs" = "btrfs"; then
    if ! helper_format "$tgtroot" btrfs "$rootlabel"; then
      yad_message "Error" "Failed to format the root filesystem $tgtroot as btrfs. A log file can be found at $log."
      stage_dec; stage_dec
      return
    fi
    # Format boot partition as btrfs if we need to.
    if test ! -z "$tgtboot" && ! helper_format "$tgtboot" btrfs "$rootlabel BOOT"; then
      yad_message "Error" "Failed to format the boot partition $tgtboot as btrfs. A log file can be found at $log."
      stage_dec; stage_dec
      return
    fi
  else
    if ! helper_format "$tgtroot" ext4 "$rootlabel"; then
      yad_message "Error" "Failed to format the root filesystem $tgtroot as ext4. A log file can be found at $log."
      stage_dec; stage_dec
      return
    fi
    # Format root partition as ext4 if we need to.
    if test ! -z "$tgtboot" && ! helper_format "$tgtboot" ext4 "$rootlabel BOOT"; then
      yad_message "Error" "Failed to format the boot partition $tgtboot as ext4. A log file can be found at $log."
      stage_dec; stage_dec
      return
    fi
  fi
  echo "75" >&"${formatprogress[1]}"
  if test $efimode -eq 1 && test $tgtefiformat -eq 1 && ! helper_format "$tgtefi" vfat "EFI SYSTEM"; then
    yad_message "Error" "Failed to format the EFI System Partition $tgtefi as vfat. A log file can be found at $log."
    stage_dec; stage_dec
    return
  fi
  echo "100" >&"${formatprogress[1]}"
  # Move on to the next stage.
  stage_inc
}
stage_mount() {
  # Ensure we know which partitions we are working with.
  if test -z "$tgtroot"; then
    # Step back a stage, because we don't know what we are working with.
    stage_dec
    return
  fi
  sync
  # Try to mount the root partition, ready for installation.
  if ! helper_mount "$tgtroot" "$tgtpath"; then
    # Complain and go back to the disk setup stage.
    yad_message "Error" "Unable to mount the root partition $tgtroot. The installation cannot continue. A log file can be found at $log."
    # TODO: Give the user a choice to either retry or go back to diskpar stage.
    stage_dec
    return
  fi
  # Mount the boot partition if needed.
  if test ! -z "$tgtboot" && ! helper_mount "$tgtboot" "$tgtpath/boot"; then
    yad_message "Error" "Unable to mount the boot partition $tgtboot. The installation cannot continue. A log file can be found at $log."
  fi
  # Mount the EFI partition if needed.
  if { test $efimode -eq 1 || test $tgtfullport -eq 1; } && ! helper_mount "$tgtefi" "$tgtpath/boot/efi"; then
    yad_message "Error" "Unable to mount the EFI system partition $tgtroot. The installation cannot continue. A log file can be found at $log."
    stage_dec
    return
  fi
  # If we got through without issues, then lets begin the installation.
  stage_inc
}
stage_swapsetup() {
  # Additional stage to handle setting up the swap file.
  # Do nothing if we are not using swap space.
  if test -z "$tgtswap"; then
    stage_inc
    return
  fi
  # A different setup is needed depending on which filesystem we are using.
  write_log "Trying to create and activate a $tgtswap swapfile."
  if test "$(blkid -o value -s TYPE "$tgtroot")" = "btrfs"; then
    # The btrfs program provides a command which does all the needed setup.
    btrfs -v filesystem mkswapfile --size "$tgtswap" "$tgtpath"/swapfile &>>"$log"
  else
    # We need to manually create it for ext4.
    {
      # Sync between every operation for robustness.
      sync; fallocate -vl "$tgtswap" "$tgtpath"/swapfile
      sync; chmod -v 0600 "$tgtpath"/swapfile
      sync; mkswap "$tgtpath"/swapfile
    } &>>"$log"
  fi
  # Try to activate the newly created swapfile.
  sync
  if ! swapon "$tgtpath"/swapfile &>>"$log"; then
    # Unable to create and activate the swap file, remove if it needed.
    rm -fv "$tgtpath"/swapfile &>>"$log"
    # Display the message.
    write_log "Failed to create and activate a $tgtswap swapfile."
    yad_message "Warning" "The $tgtswap swapfile could not be created and activated. The installation will continue without swap space. A log file can be found at $log."
    # Change the global swap space variable to disabled, so it won't be used.
    export tgtswap=""
  else
    write_log "Successfully created and activated a $tgtswap swapfile."
  fi
  # Go to the next stage.
  stage_inc
  return
}
stage_installation() {
  # This is where the fun happens.
  # One last check to ensure the partitions are mounted before continuing.
  sync
  if ! mount | grep "$tgtroot" &>/dev/null || { test $efimode -eq 1 && ! mount | grep "$tgtefi" &>/dev/null; }; then
    # Return to the mounting stage.
    stage_dec
    return
  fi
  # Determine whether we are using a squashfs or tar image.
  if test "$(file -b "$OSINSTALLGUI_ROOTFS" | cut -d' ' -f1)" = "Squashfs"; then
    # Unsquash the image.
    write_log "Unsquashing $OSINSTALLGUI_ROOTFS to $tgtpath."
    # Unsquash with percentage and pipe to yad for progress bar.
    unsquashfs -f -q -percentage -d "$tgtpath" "$OSINSTALLGUI_ROOTFS" 2>>"$log" | yad --progress --title="Installation ⎯ $inv" --text="The installation of $osname is in progress. Please be patient while the system is being installed." --percentage=0 --auto-close --no-buttons --no-escape --width=600 --height=100
    if test $? -ne 0; then
      write_log "Failed to unsquash $OSINSTALLGUI_ROOTFS to $tgtpath."
      yad_message "Error" "The installation process did not complete successfully (unsquashfs operation failed). A log file can be found at $log."
      # Return to the main menu because reboot will probably be needed.
      export stage=0
      return
    fi
    write_log "Successfully unsquashed $OSINSTALLGUI_ROOTFS to $tgtpath."
  else
    # Untar the image.
    write_log "Untarring $OSINSTALLGUI_ROOTFS to $tgtpath."
    # TODO: Make a percentage progress bar for tar, not just squashfs.
    tar -xpf "$OSINSTALLGUI_ROOTFS" -C "$tgtpath" &>>"$log"
    if test $? -ne 0; then
      write_log "Failed to untar $OSINSTALLGUI_ROOTFS to $tgtpath."
      yad_message "Error" "The installation process did not complete successfully (tar operation failed). A log file can be found at $log."
      # Return to the main menu because reboot will probably be needed.
      export stage=0
      return
    fi
    write_log "Successfully untarred $OSINSTALLGUI_ROOTFS to $tgtpath."
  fi
  # Set permissions of root directory to 755 manually after extraction.
  # This avoids world-writable '/' if rootfs lacks root directory metadata.
  chmod 0755 "$tgtpath" &>/dev/null
  # Now move to the post installation stage.
  sync
  stage_inc
}
stage_postinstall() {
  # This stage only exists for running the specified rootfs cleanup script.
  # Only need to do anything if the cleanup script was set in the config.
  if test ! -z "$OSINSTALLGUI_CLEANUP_CMD"; then
    # Ensure the file is executable.
    if test ! -x "$tgtpath/$OSINSTALLGUI_CLEANUP_CMD"; then
      # Warn about the problem, even though it is not fatal.
      yad_message "Error" "Cannot run the rootfs cleanup script because it does not exist or is not executable. This stage of the installation will therefore be skipped, which may cause the newly installed system to be tainted."
      # Move on to the next stage (system configuration) immediately.
      stage_inc
      return
    fi
    # Run the script.
    write_log "Running the rootfs cleanup script $OSINSTALLGUI_CLEANUP_CMD."
    # Try to run the script.
    if ! helper_chroot_advanced "$tgtpath" "$OSINSTALLGUI_CLEANUP_CMD"; then
      # Warn about it exiting unsuccessfully. But again still continue.
      write_log "The rootfs cleanup script did not complete successfully."
      yad_message "Error" "The rootfs cleanup script did not complete successfully. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully ran the rootfs cleanup script $OSINSTALLGUI_CLEANUP_CMD."
    fi
  fi
  # Go to the next stage, which will be the full system configuration.
  stage_inc
}
stage_systemconfig() {
  # This stage is for configuring the system after the installation.
  # Set up a progress bar using coproc, which we will update ourselves.
  coproc systemconfigprogress { yad --progress --title="Installation ⎯ $inv" --text="Configuring the system, please be patient." --percentage=0 --auto-close --auto-kill --no-buttons --no-escape --width=600 --height=100; }
  # Generate the fstab file (and crypttab file, if needed).
  write_log "Generating /etc/fstab for the target system."
  # Do all echos in a block and only write at the end, as required by SC2129.
  {
    echo "# This /etc/fstab was automatically generated by osinstallgui."
    echo "# Do not modify unless you know what you are doing."
    echo "# Any mistakes in this file could prevent the system from booting."
    if test $tgtluks -eq 1; then
      echo "# This installation was also configured for LUKS encryption."
      echo "# The raw root device is set up in /etc/crypttab."
    fi
    # Root filesystem fstab entry.
    echo "UUID=$(blkid -o value -s UUID "$tgtroot") / $tgtfs defaults 1 1"
    # Boot partition fstab entry.
    if test ! -z "$tgtboot"; then
      echo "UUID=$(blkid -o value -s UUID "$tgtboot") /boot $tgtfs defaults 1 2"
    fi
    # EFI system partition fstab entry.
    if test ! -z "$tgtefi"; then
      echo "UUID=$(blkid -o value -s UUID "$tgtefi") /boot/efi vfat umask=0077 0 2"
    fi
    # Swapfile fstab entry.
    if test ! -z "$tgtswap"; then
      echo "/swapfile none swap sw 0 0"
    fi
  } > "$tgtpath"/etc/fstab
  if test $tgtluks -eq 1; then
    {
      echo "# This /etc/crypttab was automatically generated by osinstallgui."
      echo "# This is because the installation was configured to use LUKS."
      echo "# Do not modify it, as it could prevent the system from booting."
      # Cryptroot entry.
      echo "cryptroot UUID=$(blkid -o value -s UUID "$tgtluksraw") none luks"
    } > "$tgtpath"/etc/crypttab
  fi
  write_log "Finished generation of /etc/fstab for the target system."
  echo "14" >&"${systemconfigprogress[1]}"
  # Prepare the locale for generation by uncommenting the line in the file.
  sed -i "s/#$tgtlocale/$tgtlocale/" "$tgtpath/$OSINSTALLGUI_LOCALES_FILE"
  # Generate the locales using a chroot environment.
  write_log "Generating locales in chroot using $OSINSTALLGUI_LOCALES_CMD."
  if ! helper_chroot_advanced "$tgtpath" "$OSINSTALLGUI_LOCALES_CMD"; then
    # Warn about it being unsuccessful.
    write_log "$OSINSTALLGUI_LOCALES_CMD failed to generate locales."
    yad_message "Error" "The locales could not be successfully generated on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found $log."
  else
    write_log "$OSINSTALLGUI_LOCALES_CMD successfully generated locales."
  fi
  # Set up the locale configuration file.
  echo "LANG=$tgtlocale" > "$tgtpath"/etc/locale.conf
  # Set up the keymap configuration file.
  echo "KEYMAP=$tgtkeymap" > "$tgtpath"/etc/vconsole.conf
  # Set up the X11 keymap configuration file.
  local layoutx11 variantx11
  if echo "$tgtx11key" | grep -q _; then
    # Layout and variant.
    layoutx11="$(echo "$tgtx11key" | cut -d_ -f1)"
    variantx11="$(echo "$tgtx11key" | cut -d_ -f2-)"
  else
    # Layout only.
    layoutx11="$tgtx11key"
  fi
  install -dm755 "$tgtpath"/etc/X11/xorg.conf.d
  {
    echo "# This file was automatically generated by osinstallgui."
    echo "# It sets the default X11 keymap, chosen when this OS was installed."
    echo ""
    echo "Section \"InputClass\""
    echo "    Identifier \"system-keyboard\""
    echo "    MatchIsKeyboard \"on\""
    echo "    Option \"XkbLayout\" \"$layoutx11\""
    echo "    Option \"XkbVariant\" \"$variantx11\""
    echo "    Option \"XkbModel\" \"pc105\""
    echo "    Option \"XkbOptions\" \"\""
    echo "EndSection"
  } > "$tgtpath"/etc/X11/xorg.conf.d/00-keyboard.conf
  echo "28" >&"${systemconfigprogress[1]}"
  # Set up the timezone.
  write_log "Setting timezone of target system to $tgttimezone."
  ln -sfv /usr/share/zoneinfo/"$tgttimezone" "$tgtpath"/etc/localtime  &>>"$log"
  write_log "Timezone of target system successfully set to $tgttimezone."
  # Update the hardware clock.
  # TODO: Allow localtime instead of UTC, for some distros which prefer that.
  write_log "Updating hardware clock in chroot environment."
  if ! helper_chroot_advanced "$tgtpath" /usr/bin/env hwclock -v --systohc; then
    # Warn about it being unsuccessful.
    write_log "Failed to update hardware clock in chroot environment."
    yad_message "Error" "The hardware clock could not be updated correctly on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found $log."
  else
    write_log "Successfully updated hardware clock in chroot environment."
  fi
  echo "42" >&"${systemconfigprogress[1]}"
  # Set up the root password, if a root password was specified.
  if test ! -z "$tgtrootpw"; then
    write_log "Setting the root password using chpasswd."
    if ! echo "root:$tgtrootpw" | chpasswd -R "$tgtpath" -c YESCRYPT &>>"$log"; then
      # Warn about it being unsuccessful.
      write_log "Failed to set the root password."
      yad_message "Error" "The root password could not be set on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully set the root password."
    fi
  fi
  echo "57" >&"${systemconfigprogress[1]}"
  # Set up the new primary user account - depending on whether fullname is set.
  if test ! -z "$tgtfullname"; then
    # Fullname is set.
    write_log "Creating account for $tgtusername ($tgtfullname) using useradd."
    if ! useradd -R "$tgtpath" -c "$tgtfullname" -G "$OSINSTALLGUI_ADMIN_GROUP" -ms "$OSINSTALLGUI_USER_SHELL" "$tgtusername" &>>"$log"; then
      # Warn about it being unsuccessful.
      write_log "Failed to create account for $tgtusername ($tgtfullname)."
      yad_message "Error" "The primary user account '$tgtusername' ($tgtfullname) could not be created on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully created account for $tgtusername ($tgtfullname)."
    fi
  else
    # No fullname is set.
    write_log "Creating account for $tgtusername using useradd."
    if ! useradd -R "$tgtpath" -G "$OSINSTALLGUI_ADMIN_GROUP" -ms "$OSINSTALLGUI_USER_SHELL" "$tgtusername" &>>"$log"; then
      # Warn about it being unsuccessful.
      write_log "Failed to create account for $tgtusername."
      yad_message "Error" "The primary user account '$tgtusername' could not be created on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
    else
      write_log "Successfully created account for $tgtusername."
    fi
  fi
  echo "71" >&"${systemconfigprogress[1]}"
  # Set the password for the user account.
  write_log "Setting password for $tgtusername using chpasswd."
  if ! echo "$tgtusername:$tgtuserpw" | chpasswd -R "$tgtpath" -c YESCRYPT &>>"$log"; then
    # Warn about it being unsuccessful.
    write_log "Failed to set password for $tgtusername."
    yad_message "Error" "The password for '$tgtusername' could not be set on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
  else
    write_log "Successfully set password for $tgtusername"
  fi
  echo "85" >&"${systemconfigprogress[1]}"
  # Set the hostname for the system.
  write_log "Setting the system hostname to $tgthostname."
  # Need to set in both /etc/hostname and /etc/hosts.
  # For the latter, we match the line beginning with 127.0.1.1 and replace it.
  if ! { echo "$tgthostname" > "$tgtpath"/etc/hostname && sed -i "s/^127\.0\.1\.1 .*/127.0.1.1 $tgthostname/" "$tgtpath"/etc/hosts; }; then
    # Warn about it being unsuccessful.
    write_log "Failed to set the system hostname to $tgthostname."
    yad_message "Error" "The hostname for the system could not be set on the target system. The installation process will continue anyway, however this may cause the newly installed system to be tainted. A log file can be found at $log."
  else
    write_log "Successfully set the system hostname to $tgthostname."
  fi
  echo "100" >&"${systemconfigprogress[1]}"
  # Proceed to the next stage (initramfs generation).
  stage_inc
}
stage_initramfs() {
  # Generate an initramfs for the target system.
  write_log "Generating an initramfs for the target system."
  # Pipe to yad to show something is happening (because it can take a while).
  # Without this, the program would appear closed which could confuse users.
  {
    # Won't be any visual progress indicator, but still try to log output.
    helper_chroot_advanced "$tgtpath" $OSINSTALLGUI_INITRAMFS_CMD
    # Write command status into a file on disk, else it will be lost by pipe.
    echo "$?" > "$workdir"/.status_initramfs
    # Tell yad that it is now at 100%, to finish the dialog.
    echo "100"
  } | yad --progress --title="Installation ⎯ $inv" --text="Generating an initramfs for the target system, please wait (progress will display 0% until complete)." --percentage=0 --auto-close --no-buttons --no-escape --width=600 --height=100
  if test "$(cat "$workdir"/.status_initramfs 2>&1)" != "0"; then
    # OH NO! Something went horribly wrong. Report the error.
    write_log "Failed to generate an initramfs for the target system."
    yad_message "Error" "Failed to generate an initramfs for the target system. The installation process will continue anyway, however it is VERY LIKELY that the target system will FAIL TO BOOT, and manual intervention will be needed after the installation. A log file can be found at $log."
  else
    write_log "Successfully generated an initramfs for the target system."
  fi
  # Proceed to the penultimate stage (bootloader setup).
  stage_inc
}
stage_bootloader() {
  # Install the bootloader on the target system.
  # In both cases, the '--target' option is now explicitly specified.
  # Otherwise some buggy firmwares may default to a target unsupported by GRUB.
  # Note that fully portable mode has to be installed both for BIOS and UEFI.
  # We also now no longer ask about installation type, since it's done earlier.
  # Fake progress bar, but at least it's a way to inform the user somehow.
  {
    # Legacy BIOS loader.
    if test $tgtfullport -eq 1 || test $efimode -eq 0; then
      write_log "Trying to install the GRUB bootloader for Legacy BIOS..."
      helper_chroot_advanced "$tgtpath" /usr/bin/env grub-install --target=i386-pc "$tgtdisk" $OSINSTALLGUI_GRUB_EXTRA_ARGS_LEGACY
      echo "$?" > "$workdir"/.sga1
    fi
    # UEFI loader (internal mode).
    if test $efimode -eq 1 && test $tgtfullport -eq 0; then
      write_log "Trying to install the GRUB bootloader for UEFI (internal)..."
      helper_chroot_advanced "$tgtpath" /usr/bin/env grub-install --target=x86_64-efi $OSINSTALLGUI_GRUB_EXTRA_ARGS_UEFIIN
      echo "$?" > "$workdir"/.sga2
    fi
    # UEFI loader (removable mode - for fullyportable or internal fallback).
    if test $tgtfullport -eq 1 || { test $efimode -eq 1 && test ! -e "$tgtpath"/boot/efi/EFI/BOOT/BOOTX64.EFI; }; then
      write_log "Trying to install the GRUB bootloader for UEFI (removable)..."
      helper_chroot_advanced "$tgtpath" /usr/bin/env grub-install --target=x86_64-efi --removable $OSINSTALLGUI_GRUB_EXTRA_ARGS_UEFIRM
      echo "$?" > "$workdir"/.sga3
    fi
    # Tell yad that we are half done.
    echo "50"
    # Before GRUB configuration, modify /etc/default/grub for fullyportable.
    if test $tgtfullport -eq 1 && test -e "$tgtpath"/etc/default/grub; then
      cp "$tgtpath"/etc/default/grub{,.ORIGINAL_BACKED_UP_BY_OSINSTALLGUI}
      {
        echo ""
        echo "# The following appendages have been made by osinstallgui."
        echo "# This is because a fully portable installation was chosen."
        echo "# The original file has been backed up in the same directory."
        echo "# Note that these lines take priority over anything above."
        echo "GRUB_DEFAULT=0"
        echo "GRUB_TIMEOUT=1"
        echo "GRUB_TIMEOUT_STYLE=\"hidden\""
        echo "GRUB_SAVEDEFAULT=\"false\""
        echo "GRUB_DISABLE_OS_PROBER=\"true\""
      } >> "$tgtpath"/etc/default/grub
    fi
    # GRUB configuration step.
    write_log "Trying to configure the GRUB bootloader with grub-mkconfig..."
    helper_chroot_advanced "$tgtpath" /usr/bin/env grub-mkconfig -o /boot/grub/grub.cfg
    echo "$?" > "$workdir"/.sgb
    # Now tell yad that we are done.
    echo "100"
  } | yad --progress --title="Installation ⎯ $inv" --text="Installing the GRUB bootloader, please be patient." --percentage=0 --auto-close --no-buttons --no-escape --width=600 --height=100
  # Check if anything went wrong during the process.
  local grubfailure=0
  for s in a1 a2 a3 b; do
    if test -f "$workdir/.sg$s" && test "$(cat "$workdir/.sg$s" 2>&1)" != "0"; then
      grubfailure=1
      break
    fi
  done
  if test $grubfailure -ne 0; then
    # Something went wrong, complain about the problem.
    write_log "Installation of the GRUB bootloader failed."
    yad_message "Error" "A failure was reported during the installation of the GRUB bootloader. Manual intervention may be needed to correct this problem and make your system bootable. A log file can be found at $log."
  else
    write_log "Installation of the GRUB bootloader was successful."
  fi
  # Go to the final stage.
  stage_inc
}
stage_finish() {
  # Deactivate the swapfile, if needed.
  if test -e "$tgtpath"/swapfile && swapon --show=NAME | grep -q "^$tgtpath/swapfile$"; then
    write_log "Trying to deactivate the swapfile."
    swapoff "$tgtpath"/swapfile &>>"$log"
    write_log "Finished deactivating the swapfile (hopefully)."
  fi
  # Unmount all filesystems and close the LUKS mapper if needed.
  write_log "Unmounting all filesystems..."
  helper_umount "$tgtpath"
  if test $tgtluks -eq 1; then
    cryptsetup close cryptroot &>>"$log"
  fi
  write_log "Finished unmounting all filesystems (hopefully)."
  # Show finishing message.
  if yad_prompt "Installation" "The installation of $osname has finished. Select 'YES' to shut down your system now, so you can restart into the new installation. Select 'NO' if, instead, you'd like to continue testing the live environment. In any case, remember to remove the installation media, to ensure you boot into the new installation as opposed to the live environment."; then
    shutdown -h now
  fi
  # Exit the thing (stage will be less than 0 so the main loop will stop).
  export stage=-1
}

# Determine our host's name.
export osname="$(grep -sm1 "^PRETTY_NAME=" /etc/os-release | cut -d= -f2 | sed 's/"//g')"
if test -z "$osname"; then
  # Use 'Linux' as a fallback, since we couldn't determine the host's name.
  export osname="Linux"
fi

# Create a temporary directory for us to use.
export workdir="$(mktemp -d /tmp/osinstallgui.XXXXXX)"

# Set up the log file.
export log="$workdir/osinstallgui.log"
touch "$log"

# Ensure we are running as root.
if test $EUID -ne 0; then
  die "$inv must be run as root (use 'sudo')."
fi

# Ensure the global config file exists, and source it if it does.
if test -f "@@CONFPATH@@"/osinstallgui.conf; then
  write_log "Sourcing config file '@@CONFPATH@@/osinstallgui.conf'."
  . "@@CONFPATH@@"/osinstallgui.conf &>>"$log" || true
  write_log "Sourced config file '@@CONFPATH@@/osinstallgui.conf'."
else
  write_log "Config file '@@CONFPATH/osinstallgui.conf' does not exist."
fi

# Do not proceed if any mandatory configuration options are not set.
for val in "$OSINSTALLGUI_ROOTFS" "$OSINSTALLGUI_INITRAMFS_CMD" "$OSINSTALLGUI_LOCALES_CMD" "$OSINSTALLGUI_LOCALES_FILE" "$OSINSTALLGUI_ADMIN_GROUP" "$OSINSTALLGUI_USER_SHELL"; do
  if test -z "$val"; then
    die "$inv cannot run due to one or more missing config value(s)."
  fi
done

# Do not proceed if the rootfs file (or alternative rootfs) does not exist.
if test ! -f "$OSINSTALLGUI_ROOTFS"; then
  if test ! -f "$OSINSTALLGUI_ROOTFS_ALT"; then
    die "$inv cannot run because the configured rootfs file does not exist."
  else
    # Switch to alternate rootfs.
    write_log "Using alternative rootfs file $OSINSTALLGUI_ROOTFS_ALT."
    OSINSTALLGUI_ROOTFS="$OSINSTALLGUI_ROOTFS_ALT"
  fi
else
  write_log "Using primary rootfs file $OSINSTALLGUI_ROOTFS."
fi

# Set up defaults for configuration values which are not mandatory.
test ! -z "$OSINSTALLGUI_ALLOW_BTRFS" || OSINSTALLGUI_ALLOW_BTRFS=1
test ! -z "$OSINSTALLGUI_ALLOW_LUKS" || OSINSTALLGUI_ALLOW_LUKS=1
test ! -z "$OSINSTALLGUI_ALWAYS_OFFER_FULLPORT" || OSINSTALLGUI_ALWAYS_OFFER_FULLPORT=0
test ! -z "$OSINSTALLGUI_KEYMAPS_SYSTEMD" || OSINSTALLGUI_KEYMAPS_SYSTEMD=1
test ! -z "$OSINSTALLGUI_KEYMAPS_LOCATION" || OSINSTALLGUI_KEYMAPS_LOCATION="/usr/share/keymaps"
test ! -z "$OSINSTALLGUI_ROOTPW" || OSINSTALLGUI_ROOTPW=1
test ! -z "$OSINSTALLGUI_USER_PWSCORE" || OSINSTALLGUI_USER_PWSCORE=0

# Ensure data files exist.
if test ! -e "@@CONFPATH@@"/data/locales.desc; then
  warn "$inv could not find the file '@@CONFPATH@@/data/locales.desc'."
  warn "$inv will therefore display all locales with description 'UNKNOWN'."
fi
if test ! -e "@@CONFPATH@@"/data/keymaps.desc; then
  warn "$inv could not find the file '@@CONFPATH@@/data/keymaps.desc'."
  warn "$inv will therefore display all keymaps with description 'UNKNOWN'."
fi

# Check dependencies - ordered by importance and when they are used.
check_dep yad
check_dep xkbcli libxkbcommon
check_dep yq
check_dep sgdisk gptfdisk
check_dep parted
check_dep partprobe parted
check_dep mkfs.ext4 e2fsprogs
check_dep mkfs.fat dosfstools
check_dep unsquashfs squashfs-tools

# Disk and partition variables need to be accessed by the whole program.
export tgtdisk="" tgtroot="" tgtfs="" tgtefi="" tgtefiformat=0 tgtboot="" tgtfullport=0 tgtswap="" tgtsplitboot=0 tgtluks=0 tgtlukspw="" tgtluksraw=""

# Other global setup variables which need to be accessed by the whole program.
export tgtlocale="" tgtkeymap="" tgtx11key="" tgttimezone="" tgtrootpw="" tgtusername="" tgtfullname="" tgtuserpw="" tgthostname=""

# Set up the mount directory for the target system.
export tgtpath="$workdir/target"
mkdir -p "$tgtpath"

# Determine whether our host is booted in Legacy BIOS or UEFI mode.
if test -e /sys/firmware/efi/systab; then
  export efimode=1
else
  export efimode=0
fi

# Set the current stage we are on.
export stage=0

# Allow the stage to be incremented and decremented as needed.
stage_inc() {
  export stage=$((stage + 1))
}
stage_dec() {
  export stage=$((stage - 1))
}

# Export variables that will be set by preloader.
export locales=() localescore=() keymaps=() keymapscore=() x11keys=() x11keyscore=()

# Run preloader function to get locales, keymaps and timezones.
preloader

# Enter the main program loop.
while test $stage -ge 0; do
  # Run the function corresponding to the stage we are currently on.
  case $stage in
    0) stage_mainmenu ;;
    1) stage_initinstall ;;
    2) stage_locale ;;
    3) stage_keymap ;;
    4) stage_x11key ;;
    5) stage_timezone ;;
    6) stage_rootpw ;;
    7) stage_usersetup ;;
    8) stage_userpw ;;
    9) stage_hostname ;;
    10) stage_diskpar ;;
    11) stage_luks ;;
    12) stage_format ;;
    13) stage_mount ;;
    14) stage_swapsetup ;;
    15) stage_installation ;;
    16) stage_postinstall ;;
    17) stage_systemconfig ;;
    18) stage_initramfs ;;
    19) stage_bootloader ;;
    20) stage_finish ;;
  esac
done
